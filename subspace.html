<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subspace Combat</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #333;
            background: linear-gradient(45deg, #001122 0%, #002244 50%, #001122 100%);
            /* Remove CSS scaling to prevent resampling blur */
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            color: #00ffff;
            font-size: 12px;
            font-weight: bold;
            line-height: 1.4;
            text-shadow: 1px 1px 2px #000, 0 0 6px #00ffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #00ffff;
            min-width: 180px;
        }

        .energy-bar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.5);
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            transition: width 0.1s ease;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #888;
            line-height: 1.3;
        }

        .power-up-message {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000, 0 0 15px #ffff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #ffff00;
            animation: powerUpAnnounce 3s ease-out forwards;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }

        @keyframes powerUpAnnounce {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1.1);
            }
            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) scale(1);
            }
        }

        .radar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #0ff;
            border-radius: 50%;
            background: rgba(0, 50, 50, 0.3);
        }

        .config-panel {
            position: fixed;
            top: 10px;
            right: 170px;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            border-radius: 6px;
            padding: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            width: 280px;
            display: none;
        }

        .config-panel h3 {
            margin: 0 0 10px 0;
            color: #ffff00;
            text-align: center;
        }

        .config-slider {
            margin: 8px 0;
        }

        .config-slider label {
            display: block;
            margin-bottom: 3px;
        }

        .config-slider input {
            width: 100%;
            background: #001122;
            border: 1px solid #0ff;
        }

        .config-slider .value {
            color: #ffff00;
            float: right;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1600" height="1000"></canvas>

        <div class="hud">
            <div>Energy: <span id="energy">1100</span> / <span id="maxEnergy">1100</span></div>
            <div>Boost: <span id="boostStatus">Ready</span></div>
            <div>Shield: <span id="shieldStatus">Inactive</span></div>
            <div>Bounty: <span id="powerUps">0</span></div>
            <div>Walls: <span id="wallCount">0</span></div>
            <div>Deaths: <span id="deaths">0</span></div>
            <div style="margin-top: 10px; border-top: 1px solid #0ff; padding-top: 5px;">
                <div style="font-size: 10px; color: #aaa;">SHIP & UPGRADES:</div>
                <div>Ship: <button onclick="window.game.changeShip(-1)" style="background: #0ff; color: #000; border: none; padding: 2px 6px;">◀</button> <span id="shipType">Warbird</span> <button onclick="window.game.changeShip(1)" style="background: #0ff; color: #000; border: none; padding: 2px 6px;">▶</button></div>
                <div>Energy: Lv.<span id="energyLevel">0</span> (Max: <span id="maxEnergy">1100</span>)</div>
                <div>Speed: Lv.<span id="speedLevel">0</span> (Max: <span id="maxSpeed">500</span>)</div>
                <div>Guns: <span id="bulletType">Red</span> <span id="bulletBounce"></span> (DMG: <span id="bulletDamage">30</span>)</div>
                <div>Bombs: <span id="bombType">Red</span></div>
                <div>Recharge: Lv.<span id="rechargeLevel">0</span> (+<span id="rechargeRate">0</span>%)</div>
                <div>Thrust: Lv.<span id="thrustLevel">0</span> (+<span id="thrustBonus">0</span>%)</div>
                <div>Rotation: Lv.<span id="rotationLevel">0</span> (+<span id="rotationBonus">0</span>%)</div>
            </div>
        </div>

        <div class="energy-bar">
            <div class="energy-fill" id="energyFill"></div>
        </div>

        <div class="controls">
            <div><strong>SUBSPACE CONTROLS:</strong></div>
            <div>A/D - Rotate Left/Right</div>
            <div>W - Thrust</div>
            <div>SHIFT + W - Boost (double speed, heavy energy drain)</div>
            <div>S - Reverse Thrust</div>
            <div>CTRL - Fire Bullets</div>
            <div>TAB - Fire Bombs</div>
            <div>F2 - Deploy Wall</div>
            <div>F3 - Burst Push</div>
            <div>SPACE - Brake</div>
            <div style="margin-top: 10px; border-top: 1px solid #0ff; padding-top: 5px;">
                <button id="multiplayerBtn" onclick="game.connectToMultiplayer()" style="background: #000; color: #0ff; border: 1px solid #0ff; padding: 5px 10px; font-family: inherit; font-size: 12px; cursor: pointer;">JOIN MULTIPLAYER</button>
                <div id="multiplayerStatus" style="font-size: 10px; color: #888; margin-top: 5px;"></div>
            </div>
        </div>

        <div class="radar" id="radar">
            <canvas id="radarCanvas" width="146" height="146" style="border-radius: 50%; display: block;"></canvas>
        </div>

        <!-- Ship Configuration Panel (F12 to toggle) -->
        <div class="config-panel" id="configPanel">
            <h3>⚙️ UPGRADE LEVELS (F12)</h3>

            <div class="config-slider">
                <label>Energy Level <span class="value" id="energyLevelValue">0</span></label>
                <input type="range" id="energyLevelSlider" min="0" max="5" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Speed Level <span class="value" id="speedLevelValue">0</span></label>
                <input type="range" id="speedLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Weapon Level <span class="value" id="weaponLevelValue">0</span> (Red/Yellow/Green)</label>
                <input type="range" id="weaponLevelSlider" min="0" max="2" step="1" value="0">
            </div>

            <div class="config-slider">
                <label><input type="checkbox" id="bulletBounceCheckbox"> Bullet Bouncing</label>
            </div>

            <div class="config-slider">
                <label>Recharge Level <span class="value" id="rechargeLevelValue">0</span></label>
                <input type="range" id="rechargeLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Thrust Level <span class="value" id="thrustLevelValue">0</span></label>
                <input type="range" id="thrustLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Rotation Level <span class="value" id="rotationLevelValue">0</span></label>
                <input type="range" id="rotationLevelSlider" min="0" max="3" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Wall Count <span class="value" id="wallCountValue">0</span></label>
                <input type="range" id="wallCountSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Fire Rate <span class="value" id="fireRateValue">0.7</span></label>
                <input type="range" id="fireRateSlider" min="0.3" max="2.0" step="0.1" value="0.7">
            </div>

            <div style="text-align: center; margin-top: 15px; font-size: 10px; color: #888;">
                <div>Set upgrade levels directly</div>
                <div>F12 to toggle panel</div>
            </div>

            <hr style="border: none; border-top: 1px solid #044; margin: 12px 0;">

            <h4 style="margin-bottom: 6px; text-align: center;">Power-Up Spawner</h4>
            <div id="powerUpSpawner" style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px 12px; font-size: 11px;">
                <label><input type="checkbox" class="powerup-checkbox" value="energy"> Energy</label>
                <label><input type="checkbox" class="powerup-checkbox" value="speed"> Speed</label>
                <label><input type="checkbox" class="powerup-checkbox" value="weapons"> Weapons</label>
                <label><input type="checkbox" class="powerup-checkbox" value="shield"> Shield</label>
                <label><input type="checkbox" class="powerup-checkbox" value="recharge"> Recharge</label>
                <label><input type="checkbox" class="powerup-checkbox" value="thrust"> Thrust</label>
                <label><input type="checkbox" class="powerup-checkbox" value="rotation"> Rotation</label>
                <label><input type="checkbox" class="powerup-checkbox" value="wall"> Wall</label>
                <label><input type="checkbox" class="powerup-checkbox" value="bouncing"> Bouncing</label>
            </div>

            <div class="config-slider" style="margin-top: 10px;">
                <label>Count <span class="value" id="spawnPowerUpCountValue">1</span></label>
                <input type="number" id="spawnPowerUpCount" min="1" max="250" value="1" style="width: 100%;">
            </div>

            <button id="spawnPowerUpsBtn" style="width: 100%; padding: 6px; margin-top: 6px; background: #044; color: #0ff; border: 1px solid #0ff; cursor: pointer;">Spawn Selected Power-Ups</button>
            <button id="clearPowerUpsBtn" style="width: 100%; padding: 6px; margin-top: 6px; background: #400; color: #f88; border: 1px solid #f88; cursor: pointer;">Clear Nearby Power-Ups</button>
        </div>

        <!-- Power-up messages container -->
        <div id="messageContainer"></div>
    </div>

    <script>
        const WORLD_WIDTH = 8000;
        const WORLD_HEIGHT = 5200;
        const PLAYFIELD_TOP = 120;
        const PLAYFIELD_BOTTOM = WORLD_HEIGHT - 120;
        const UPGRADE_LIMITS = Object.freeze({
            energyLevel: 5,
            maxSpeedLevel: 10,
            weaponLevel: 2,  // 3 levels: 0=Red, 1=Yellow, 2=Green
            rechargeLevel: 10,
            thrustLevel: 10,
            rotationLevel: 3,
            wallCount: 10
        });

        function clampValue(value, min, max) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return min;
            }
            const rounded = Math.floor(numeric);
            return Math.max(min, Math.min(max, rounded));
        }

        function formatLevelDisplay(value, max) {
            const clamped = clampValue(value, 0, max);
            return clamped >= max ? `${clamped}★` : `${clamped}`;
        }

        function formatPercentDisplay(percent, isMax) {
            const clampedPercent = Math.round(percent);
            return isMax ? `${clampedPercent}%★` : `${clampedPercent}%`;
        }

        // Ship Configuration System
        class ShipConfig {
            constructor() {
                // Default configuration for all ships - admin adjustable
                this.shipConfigs = {
                    1: { // Warbird
                        name: 'Warbird',
                        baseSpeedMultiplier: 1.0,
                        thrustMultiplier: 1.0,
                        turnRateMultiplier: 1.0,
                        energyCapacityMultiplier: 1.0,
                        bulletDamageMultiplier: 1.0,
                        energyRechargeMultiplier: 1.0,
                        gunTimeoutMultiplier: 0.7 // 30% faster firing (shorter timeout)
                    },
                    // Future ship configs will go here
                    2: { name: 'Javelin', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    3: { name: 'Spider', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    4: { name: 'Leviathan', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    5: { name: 'Terrier', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    6: { name: 'Weasel', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    7: { name: 'Lancaster', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    8: { name: 'Shark', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 }
                };
            }

            getConfig(shipType) {
                return this.shipConfigs[shipType] || this.shipConfigs[1];
            }

            updateConfig(shipType, parameter, value) {
                if (this.shipConfigs[shipType] && this.shipConfigs[shipType].hasOwnProperty(parameter)) {
                    // Validate bounds to prevent breaking the game
                    const clampedValue = Math.max(0.1, Math.min(5.0, value)); // 10% to 500% of normal
                    this.shipConfigs[shipType][parameter] = clampedValue;
                    return true;
                }
                return false;
            }

            // Method for admin console to update configs
            setShipConfig(shipType, configObject) {
                if (this.shipConfigs[shipType]) {
                    Object.assign(this.shipConfigs[shipType], configObject);
                }
            }

            // Get all configs (for admin console)
            getAllConfigs() {
                return JSON.parse(JSON.stringify(this.shipConfigs)); // Deep copy
            }
        }

        // Global ship configuration instance
        window.shipConfig = new ShipConfig();

        // Vector2D class (simplified from valor)
        class Vector2D {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            static fromArray(arr) {
                return new Vector2D(arr[0], arr[1]);
            }

            clone() {
                return new Vector2D(this.x, this.y);
            }

            clear() {
                this.x = this.y = 0;
                return this;
            }

            set(v) {
                this.x = v.x;
                this.y = v.y;
                return this;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }

            addXY(x, y) {
                this.x += x;
                this.y += y;
                return this;
            }

            // Key Subspace mechanic: polar addition for thrust
            addPolar(magnitude, angle) {
                this.x += magnitude * Math.sin(angle);
                this.y += magnitude * -Math.cos(angle); // Negative cos for correct orientation
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }

            scale(factor) {
                this.x *= factor;
                this.y *= factor;
                return this;
            }

            clamp(max) {
                const length = this.length();
                if (length > max) {
                    const factor = max / length;
                    this.x *= factor;
                    this.y *= factor;
                }
                return this;
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
        }

        // Ship class (based on valor's Ship.coffee)
        class Ship {
            constructor(x, y, isPlayer = false, shipTypeOverride = null) {
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(0, 0);
                this.rawAngle = 0;
                this.angle = 0;
                this.isPlayer = isPlayer;

                const defaultShipType = isPlayer ? 1 : Math.floor(Math.random() * 8) + 1;
                this.shipType = shipTypeOverride != null ? shipTypeOverride : defaultShipType; // Ship types 1-8

                // Ship properties (from valor)
                this.maxSpeed = 150; // pixels/second, will be recalculated in updateStatsFromLevels()
                // Energy will be set after updateStatsFromLevels() is called
                this.fireEnergy = 20;
                // Base gun timeout (configurable by ship type)
                const baseGunTimeout = 0.5; // seconds
                const config = window.shipConfig ? window.shipConfig.getConfig(this.shipType) : { gunTimeoutMultiplier: 1.0 };
                this.gunTimeoutDefault = baseGunTimeout * (config.gunTimeoutMultiplier || 1.0);
                this.gunTimeout = 0;
                this.burstTimeout = 0;
                this.burstTimeoutDefault = 2.0; // Burst cooldown is 2 seconds
                this.energyRecharge = 50; // Energy recharge rate per second

                this.size = 18; // Reasonable triangle size
                this.hitRadius = this.size * 1.1; // Keep radius close to sprite bounds with additional padding
                this.bullets = [];

                // Boost mechanics
                this.boostActive = false;
                this.boostSpeedMultiplier = 2.0; // Shift boost doubles thrust & top speed
                this.boostEnergyUseMultiplier = 3.0; // ~300% more energy drain while boosting
                this.boostEnergyDrainPerSecond = 150; // Recomputed per ship in updateStatsFromLevels()
                this.boostMinEnergy = 50; // Require a small reserve to engage boost

                // Permanent upgrade levels (reset on death)
                this.maxSpeedLevel = 0; // +50 max speed per level
                this.weaponLevel = 0; // Bullet progression: 0=red, 1=yellow, 2=green
                this.bulletBounce = false; // Bullet bouncing enabled/disabled
                this.rechargeLevel = 0; // +200% recharge rate per level
                this.thrustLevel = 0; // +2% thrust per level
                this.energyLevel = 0; // +200 max energy per level
                this.rotationLevel = 0; // +33% turn rate per level
                this.wallCount = 0; // Number of deployable walls
                this.shieldActive = false;
                this.shieldTimer = 0;
                this.repelBoostTimer = 0;
                this.repelSpeedMultiplierActive = 1;

                // Calculate current stats based on levels
                this.updateStatsFromLevels();

                // Set initial energy to max after stats are calculated
                this.energy = this.maxEnergy;

                // Death tracking
                this.alive = true;
                this.deaths = 0;

                // Physics properties
                this.bounciness = 0.3;
                this.invmass = 1.0;

                // Graphics - use Subspace sprites
                this.spriteDrawSize = 48; // Draw 50% larger
                this.spriteSize = 32; // For compatibility
            }

            updateStatsFromLevels() {
                this.clampUpgradeLevels();

                // Get ship-specific configuration
                const config = window.shipConfig.getConfig(this.shipType);

                // Base stats (proper Subspace feel) - now configurable
                const baseMaxSpeed = 150 * config.baseSpeedMultiplier;
                const baseEnergyRecharge = 50 * config.energyRechargeMultiplier;
                const baseThrustMultiplier = 5 * config.thrustMultiplier;
                const baseMaxEnergy = 1100 * config.energyCapacityMultiplier;
                const baseGunTimeout = 0.5;

                // Calculate current stats from upgrade levels
                this.maxSpeed = baseMaxSpeed + (this.maxSpeedLevel * 5 * config.baseSpeedMultiplier);
                this.maxEnergy = baseMaxEnergy + (this.energyLevel * 200 * config.energyCapacityMultiplier);

                // Fire energy costs scale with weapon level (3 levels: Red, Yellow, Green)
                const baseBulletCost = 67;
                const energyCosts = [67, 90, 140]; // Energy cost per level
                this.fireEnergy = energyCosts[Math.min(this.weaponLevel, 2)] || baseBulletCost;
                // Reduced recharge scaling: +50% per level instead of +100%
                this.energyRecharge = baseEnergyRecharge * (1 + this.rechargeLevel * 0.5);
                this.baseEnergyRecharge = baseEnergyRecharge;
                const energyUseMultiplier = this.boostEnergyUseMultiplier || 3.0;
                this.boostEnergyDrainPerSecond = this.energyRecharge * energyUseMultiplier;
                this.thrustMultiplier = baseThrustMultiplier * (1 + this.thrustLevel * 0.02); // +2% per level - ORIGINAL VALUE
                this.gunTimeoutDefault = baseGunTimeout * (config.gunTimeoutMultiplier || 1.0);

                // Determine bullet type name for HUD display (3 levels)
                const bulletNames = ['Red', 'Yellow', 'Green'];
                this.bulletType = bulletNames[Math.min(this.weaponLevel, 2)] || 'Red';

                // Debug log for bullet level changes
                console.log(`Weapon Level: ${this.weaponLevel}, Bullet Type: ${this.bulletType}`);
            }

            clampUpgradeLevels() {
                this.energyLevel = clampValue(this.energyLevel, 0, UPGRADE_LIMITS.energyLevel);
                this.maxSpeedLevel = clampValue(this.maxSpeedLevel, 0, UPGRADE_LIMITS.maxSpeedLevel);
                this.weaponLevel = clampValue(this.weaponLevel, 0, UPGRADE_LIMITS.weaponLevel);
                this.rechargeLevel = clampValue(this.rechargeLevel, 0, UPGRADE_LIMITS.rechargeLevel);
                this.thrustLevel = clampValue(this.thrustLevel, 0, UPGRADE_LIMITS.thrustLevel);
                this.rotationLevel = clampValue(this.rotationLevel, 0, UPGRADE_LIMITS.rotationLevel);
                this.wallCount = clampValue(this.wallCount, 0, UPGRADE_LIMITS.wallCount);
            }

            resetUpgrades() {
                // Called on death - reset all permanent upgrades
                this.maxSpeedLevel = 0;
                this.weaponLevel = 0;
                this.rechargeLevel = 0;
                this.thrustLevel = 0;
                this.energyLevel = 0;
                this.rotationLevel = 0;
                this.wallCount = 0;
                this.updateStatsFromLevels();
            }

            die() {
                // Death effects and respawn
                this.alive = false;
                this.deaths++; // Increment death counter
                this.resetUpgrades();
                this.updateStatsFromLevels(); // Recalculate max energy
                this.energy = this.maxEnergy;
                this.vel.clear();
                this.shieldActive = false;
                this.shieldTimer = 0;

                // Respawn in safe zone when available
                const game = (typeof window !== 'undefined' && window.game) ? window.game : null;
                if (game && game.safeZone) {
                    const safeZone = game.safeZone;
                    const targetX = Number.isFinite(safeZone.x) ? safeZone.x : 4000;
                    const targetY = Number.isFinite(safeZone.y) ? safeZone.y : 2600;
                    const clamped = typeof game.findValidPowerUpPosition === 'function'
                        ? game.clampPositionToWorld(targetX, targetY, 40)
                        : { x: targetX, y: targetY };
                    this.pos.x = clamped.x;
                    this.pos.y = clamped.y;
                } else {
                    // Fallback to approximate world center
                    this.pos.x = 4000;
                    this.pos.y = 2600;
                }
                this.angle = 0;
                this.rawAngle = 0;

                // Clear bullets
                this.bullets = [];

                // Mark as alive again
                this.alive = true;
            }

            processInput(input, deltaTime, context = {}) {
                // Get ship-specific configuration
                const config = window.shipConfig.getConfig(this.shipType);

                // Rotation (much smoother, continuous) - now configurable with upgrades
                // Base speed reduced by 50% so max upgraded speed equals original base speed
                const baseRotationSpeed = 1.5 * config.turnRateMultiplier; // Reduced from 3.0 to 1.5
                const rotationSpeed = baseRotationSpeed * (1 + this.rotationLevel * 0.33); // +33% per level

                if (input.left) {
                    this.angle -= rotationSpeed * deltaTime;
                }
                if (input.right) {
                    this.angle += rotationSpeed * deltaTime;
                }

                // Normalize angle to 0-2π range
                while (this.angle < 0) this.angle += Math.PI * 2;
                while (this.angle >= Math.PI * 2) this.angle -= Math.PI * 2;

                // Keep rawAngle in sync for physics
                this.rawAngle = this.angle;

                // Thrust (reduced base acceleration, can be boosted by power-ups)
                const baseThrustForce = 75; // Increased thrust force by 50% (50 * 1.5 = 75)
                let thrustForce = baseThrustForce * this.thrustMultiplier;

                const boostRequested = input.boost && input.thrust;
                const hasEnergyForBoost = this.energy > this.boostMinEnergy;
                if (boostRequested && hasEnergyForBoost) {
                    this.boostActive = true;
                    thrustForce *= this.boostSpeedMultiplier;
                } else if (!boostRequested || !hasEnergyForBoost) {
                    this.boostActive = false;
                }

                const thrustDelta = thrustForce * deltaTime;
                if (input.thrust) {
                    this.vel.addPolar(thrustDelta, this.angle);
                }
                if (input.reverse) {
                    this.vel.addPolar(-thrustDelta * 0.5, this.angle);
                }

                // Brake
                if (input.brake) {
                    const brakeFactor = typeof context.brakeFactor === 'number' ? context.brakeFactor : 0.95;
                    const clampedFactor = Math.max(0, Math.min(1, brakeFactor));
                    this.vel.scale(clampedFactor);
                }

                // Firing bullets
                if (input.fire && this.gunTimeout <= 0 && this.energy >= this.fireEnergy) {
                    this.fire();
                }

                // Firing bombs
                if (input.bomb && this.gunTimeout <= 0 && this.energy >= this.getBombEnergy()) {
                    this.fireBomb();
                }

                if (input.deployMine && this.gunTimeout <= 0 && this.energy >= this.getBombEnergy()) {
                    this.deployMine();
                }

                // Deploy wall
                if (input.deployWall && this.wallCount > 0 && this.gunTimeout <= 0) {
                    this.deployWall();
                }

                // Burst - pushes everything away
                if (input.burst && this.burstTimeout <= 0 && this.energy >= this.getBurstEnergy()) {
                    this.burst();
                }
            }

            fire() {
                // Check if ship is in safe zone - bullets cannot be fired from there
                if (window.game && window.game.isInSafeZone && window.game.isInSafeZone(this.pos.x, this.pos.y)) {
                    return;
                }

                this.energy -= this.fireEnergy;
                this.gunTimeout = this.gunTimeoutDefault;

                // Create bullet with ship velocity + bullet velocity
                const ownerId = (window.game && window.game.playerId) ? window.game.playerId : 'local';
                const bullet = new Bullet(
                    this.pos.x + Math.sin(this.angle) * this.size,
                    this.pos.y + -Math.cos(this.angle) * this.size,
                    this.vel.x + Math.sin(this.angle) * 600, // Bullet speed
                    this.vel.y + -Math.cos(this.angle) * 600,
                    this.weaponLevel, // Pass weapon level directly (0-2)
                    ownerId,
                    this.bulletBounce // Pass bounce property from ship
                );

                this.bullets.push(bullet);

                // Send bullet to multiplayer server if connected
                if (window.game && window.game.isMultiplayer) {
                    window.game.sendMultiplayerMessage({
                        type: 'bullet',
                        playerId: ownerId,
                        x: bullet.pos.x,
                        y: bullet.pos.y,
                        vx: bullet.vel.x,
                        vy: bullet.vel.y,
                        weaponLevel: this.weaponLevel,
                        canBounce: this.bulletBounce
                    });
                }
            }

            getBombEnergy() {
                // Red bombs cost 350 energy, Yellow bombs cost 450 energy (allows ~3-5 bombs)
                return this.bulletType === 'yellow' ? 450 : 350;
            }

            fireBomb() {
                // Check if ship is in safe zone - bombs cannot be fired from there
                if (window.game && window.game.isInSafeZone && window.game.isInSafeZone(this.pos.x, this.pos.y)) {
                    return;
                }

                const bombEnergy = this.getBombEnergy();
                this.energy -= bombEnergy;
                this.gunTimeout = this.gunTimeoutDefault * 2; // Longer timeout for bombs

                // Create bomb with ship velocity + bomb velocity
                const ownerId = (window.game && window.game.playerId) ? window.game.playerId : 'local';
                const bombId = window.game ? window.game.generateEntityId('bomb') : `bomb_${Date.now()}`;
                const createdAt = Date.now();
                const bomb = new Bomb(
                    this.pos.x + Math.sin(this.angle) * this.size,
                    this.pos.y + -Math.cos(this.angle) * this.size,
                    this.vel.x + Math.sin(this.angle) * 300, // Slower than bullets
                    this.vel.y + -Math.cos(this.angle) * 300,
                    this.bulletType === 'yellow' ? 'yellow' : 'red', // Only red and yellow bombs
                    this.weaponLevel, // Pass weapon level for bouncing logic
                    ownerId,
                    { id: bombId, createdAt }
                );

                // Add to game's bomb array (we'll need to pass this reference)
                if (window.game && window.game.bombs) {
                    window.game.bombs.push(bomb);

                    // Send bomb to multiplayer server if connected
                    if (window.game.isMultiplayer) {
                        window.game.sendMultiplayerMessage({
                            type: 'bomb',
                            playerId: ownerId,
                            x: bomb.pos.x,
                            y: bomb.pos.y,
                            vx: bomb.vel.x,
                            vy: bomb.vel.y,
                            bombType: bomb.bombType,
                            color: bomb.color,
                            weaponLevel: this.weaponLevel,
                            bombId: bomb.id,
                            createdAt: bomb.createdAt
                        });
                    }
                }
            }

            deployMine() {
                const mineEnergy = this.getBombEnergy();
                if (this.energy < mineEnergy || !window.game) {
                    return;
                }

                // Check if ship is in safe zone - mines cannot be deployed there
                if (window.game.isInSafeZone && window.game.isInSafeZone(this.pos.x, this.pos.y)) {
                    return;
                }

                const ownerId = window.game.playerId ? window.game.playerId : 'local';
                if (window.game.countActiveMines(ownerId) >= window.game.mineLimit) {
                    return;
                }

                this.energy -= mineEnergy;
                this.gunTimeout = this.gunTimeoutDefault * 2;
                const mineId = window.game.generateEntityId('mine');
                const createdAt = Date.now();

                const mine = new Bomb(
                    this.pos.x,
                    this.pos.y,
                    0,
                    0,
                    this.bulletType === 'yellow' ? 'yellow' : 'red',
                    this.weaponLevel,
                    ownerId,
                    { isMine: true, id: mineId, createdAt }
                );

                window.game.bombs.push(mine);

                if (window.game.isMultiplayer) {
                    window.game.sendMultiplayerMessage({
                        type: 'bomb',
                        playerId: ownerId,
                        x: mine.pos.x,
                        y: mine.pos.y,
                        vx: 0,
                        vy: 0,
                        bombType: mine.bombType,
                        color: mine.color,
                        weaponLevel: this.weaponLevel,
                        isMine: true,
                        bombId: mine.id,
                        createdAt: mine.createdAt
                    });
                }
            }

            deployWall() {
                this.wallCount--;
                this.gunTimeout = this.gunTimeoutDefault; // Small timeout after deploying

                // Create wall behind ship
                if (window.game && window.game.walls) {
                    const wall = new Wall(this.pos.x, this.pos.y, this.angle);
                    window.game.walls.push(wall);

                    // Send wall to multiplayer server if connected
                    if (window.game.isMultiplayer) {
                        window.game.sendMultiplayerMessage({
                            type: 'wall',
                            bricks: wall.bricks.map(brick => ({ x: brick.x, y: brick.y }))
                        });
                    }
                }
            }

            getBurstEnergy() {
                // Burst costs 250 energy
                return 250;
            }

            burst() {
                const burstEnergy = this.getBurstEnergy();
                this.energy -= burstEnergy;
                this.burstTimeout = this.burstTimeoutDefault;

                if (window.game) {
                    const sourceId = window.game.playerId || 'local';
                    window.game.triggerRepel(this.pos.x, this.pos.y, sourceId, true);
                }
            }

            activateShield(duration = 10) {
                this.shieldActive = true;
                this.shieldTimer = duration;
            }

            isShieldActive() {
                return this.shieldActive && this.shieldTimer > 0;
            }

            update(deltaTime) {
                // Update timers
                if (this.gunTimeout > 0) {
                    this.gunTimeout -= deltaTime;
                }
                if (this.burstTimeout > 0) {
                    this.burstTimeout -= deltaTime;
                }
                if (this.repelBoostTimer > 0) {
                    this.repelBoostTimer = Math.max(0, this.repelBoostTimer - deltaTime);
                    if (this.repelBoostTimer <= 0) {
                        this.repelSpeedMultiplierActive = 1;
                    }
                }

                // Energy recharge (based on current upgrade level)
                if (this.energy < this.maxEnergy) {
                    this.energy = Math.min(this.maxEnergy, this.energy + this.energyRecharge * deltaTime);
                }

                // Boost drains energy heavily (~300% of passive recharge)
                if (this.boostActive && this.boostEnergyDrainPerSecond > 0) {
                    const boostCost = this.boostEnergyDrainPerSecond * deltaTime;
                    if (boostCost > 0) {
                        this.energy = Math.max(0, this.energy - boostCost);
                        if (this.energy <= 0) {
                            this.boostActive = false;
                        }
                    }
                }

                if (this.shieldActive) {
                    this.shieldTimer = Math.max(0, this.shieldTimer - deltaTime);
                    if (this.shieldTimer <= 0) {
                        this.shieldActive = false;
                    }
                }

                // Apply velocity limits
                let speedMultiplier = this.boostActive ? this.boostSpeedMultiplier : 1;
                if (this.repelBoostTimer > 0) {
                    speedMultiplier = Math.max(speedMultiplier, this.repelSpeedMultiplierActive);
                }
                const speedCap = this.maxSpeed * speedMultiplier;
                this.vel.clamp(speedCap);

                // Update position (apply velocity scaled by deltaTime for proper units)
                this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));

                // Clamp ship to world boundaries
                const margin = this.hitRadius !== undefined ? this.hitRadius : this.size;
                const oldX = this.pos.x;
                const oldY = this.pos.y;
                const minX = margin;
                const maxX = WORLD_WIDTH - margin;
                const minY = PLAYFIELD_TOP + margin;
                const maxY = PLAYFIELD_BOTTOM - margin;
                this.pos.x = Math.max(minX, Math.min(maxX, this.pos.x));
                this.pos.y = Math.max(minY, Math.min(maxY, this.pos.y));

                // Stop velocity when hitting boundaries to prevent visual issues
                if (oldX !== this.pos.x) {
                    this.vel.x = 0;
                }
                if (oldY !== this.pos.y) {
                    this.vel.y = 0;
                }

                // Debug: Log when clamping occurs
                if (oldX !== this.pos.x || oldY !== this.pos.y) {
                    console.log(`Ship clamped: (${oldX.toFixed(1)}, ${oldY.toFixed(1)}) -> (${this.pos.x.toFixed(1)}, ${this.pos.y.toFixed(1)})`);
                }

                // Check for death conditions (only energy-based now, position is clamped)
                if (this.energy <= 0) {
                    this.die();
                    return; // Early exit to prevent further updates
                }


                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.update(deltaTime);

                    if (bullet.expired()) {
                        this.bullets.splice(i, 1);
                    }
                }
            }

            draw(ctx, viewport) {
                // Convert world coordinates to screen coordinates
                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);

                // Set image smoothing for crisp pixel art
                ctx.imageSmoothingEnabled = false;

                ctx.save();

                // Move to ship center
                ctx.translate(screenPos.x, screenPos.y);

                // Don't rotate canvas - the sprite frames are already rotated
                // (Only rotate if we need to draw fallback triangle)
                // Try to draw ship sprite
                let spriteDrawn = false;

                if (window.game && window.game.shipLoaded && window.game.drawShipSprite) {
                    try {
                        spriteDrawn = window.game.drawShipSprite(this.shipType, 0, 0, this.angle);
                    } catch (e) {
                        console.log('Ship sprite drawing failed:', e);
                    }
                }

                // If sprite failed, apply rotation for fallback triangle
                if (!spriteDrawn) {
                    ctx.rotate(this.angle);
                }

                if (!spriteDrawn) {
                    // Fallback triangle
                    ctx.fillStyle = this.isPlayer ? '#00ff00' : '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(-this.size * 0.6, this.size * 0.8);
                    ctx.lineTo(0, this.size * 0.4);
                    ctx.lineTo(this.size * 0.6, this.size * 0.8);
                    ctx.closePath();
                    ctx.fill();
                }

                if (this.isShieldActive()) {
                    const radius = (this.spriteDrawSize ? this.spriteDrawSize / 2 : this.size) + 10;
                    const pulse = 0.4 + 0.2 * Math.sin(Date.now() / 150);
                    ctx.globalAlpha = pulse;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                ctx.restore();

                // Restore smoothing for other elements
                ctx.imageSmoothingEnabled = true;

                // Draw bullets
                this.bullets.forEach(bullet => bullet.draw(ctx, viewport));
            }
        }

        // PowerUp class
        class PowerUp {
            constructor(x, y, type) {
                this.pos = new Vector2D(x, y);
                this.type = type;
                this.collected = false;
                this.size = 16;
                this.bounceTime = 0;

                // Power-up types and their effects (permanent until death)
                this.types = {
                    energy: {
                        spriteIndex: 0,
                        color: '#ffff00',
                        effect: 'energy',
                        name: 'ENERGY UPGRADE',
                        message: '+200 Max Energy (Permanent!)'
                    },
                    speed: {
                        spriteIndex: 1,
                        color: '#00ff00',
                        effect: 'speed',
                        name: 'SPEED UPGRADE',
                        message: '+50 Max Speed (Permanent!)'
                    },
                    weapons: {
                        spriteIndex: 2,
                        color: '#ff0000',
                        effect: 'weapons',
                        name: 'WEAPON UPGRADE',
                        message: 'Bullet Upgrade (+100% Energy Cost!)'
                    },
                    shield: {
                        spriteIndex: 3,
                        color: '#0080ff',
                        effect: 'shield',
                        name: 'SHIELD BOOST',
                        message: '10s Protective Barrier!'
                    },
                    recharge: {
                        spriteIndex: 4,
                        color: '#ff8000',
                        effect: 'recharge',
                        name: 'RECHARGE UPGRADE',
                        message: '+200% Recharge Rate (Permanent!)'
                    },
                    thrust: {
                        spriteIndex: 5,
                        color: '#ff00ff',
                        effect: 'thrust',
                        name: 'THRUST UPGRADE',
                        message: '+2% Acceleration (Permanent!)'
                    },
                    wall: {
                        spriteIndex: 6,
                        color: '#888888',
                        effect: 'wall',
                        name: 'WALL DEPLOYMENT',
                        message: 'Deploys protective wall behind ship!'
                    },
                    rotation: {
                        spriteIndex: 7,
                        color: '#ff8800',
                        effect: 'rotation',
                        name: 'ROTATION UPGRADE',
                        message: '+33% Turn Rate (Permanent!)'
                    },
                    bouncing: {
                        spriteIndex: 7,  // TODO: needs unique sprite (currently shares with rotation)
                        color: '#00ffff',
                        effect: 'bouncing',
                        name: 'BOUNCING BULLETS',
                        message: 'Bullets bounce off walls!'
                    }
                };

                this.config = this.types[type] || this.types.energy;

                // Load power-up sprite
                this.powerUpImage = new Image();
                this.powerUpImage.src = 'powerb.png';
                this.spriteSize = 16; // Each power-up is 16x16
            }

            update(deltaTime) {
                this.bounceTime += deltaTime * 4;
            }

            draw(ctx, viewport) {
                if (this.collected) return;

                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                const bounceOffset = Math.sin(this.bounceTime) * 3;

                ctx.save();
                ctx.imageSmoothingEnabled = false;

                if (this.powerUpImage.complete) {
                    // Draw specific power-up frame from sprite sheet
                    const sx = this.config.spriteIndex * this.spriteSize;
                    const sy = 0; // Power-ups are in a single row

                    ctx.drawImage(
                        this.powerUpImage,
                        sx, sy, this.spriteSize, this.spriteSize,
                        screenPos.x - this.size / 2,
                        screenPos.y - this.size / 2 + bounceOffset,
                        this.size, this.size
                    );
                } else {
                    // Fallback colored circle
                    ctx.fillStyle = this.config.color;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y + bounceOffset, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Glow effect
                ctx.globalAlpha = 0.3 + Math.sin(this.bounceTime * 2) * 0.2;
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y + bounceOffset, this.size / 2 + 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            checkCollision(ship) {
                if (this.collected) return false;

                const distance = Math.sqrt(
                    (this.pos.x - ship.pos.x) ** 2 +
                    (this.pos.y - ship.pos.y) ** 2
                );

                const pickupRadius = (this.size + ship.size) / 2;
                return distance < pickupRadius * 1.1; // Expand ship + power-up hitbox ~10%
            }

            applyEffect(ship) {
                if (this.collected) return;

                this.collected = true;

                switch (this.config.effect) {
                    case 'energy':
                        // Permanent max energy upgrade
                        if (ship.energyLevel < UPGRADE_LIMITS.energyLevel) {
                            ship.energyLevel++;
                            ship.updateStatsFromLevels();
                            ship.energy = ship.maxEnergy; // Fill to new max
                        }
                        break;
                    case 'speed':
                        // Permanent speed upgrade
                        if (ship.maxSpeedLevel < UPGRADE_LIMITS.maxSpeedLevel) {
                            ship.maxSpeedLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'weapons':
                        // Permanent weapon upgrade (6-level progression up to Green+)
                        if (ship.weaponLevel < UPGRADE_LIMITS.weaponLevel) {
                            ship.weaponLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'shield':
                        ship.activateShield(10);
                        break;
                    case 'recharge':
                        // Permanent recharge upgrade
                        if (ship.rechargeLevel < UPGRADE_LIMITS.rechargeLevel) {
                            ship.rechargeLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'thrust':
                        // Permanent thrust upgrade
                        if (ship.thrustLevel < UPGRADE_LIMITS.thrustLevel) {
                            ship.thrustLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'wall':
                        // Add wall to inventory
                        if (ship.wallCount < UPGRADE_LIMITS.wallCount) {
                            ship.wallCount++;
                        }
                        break;
                    case 'rotation':
                        // Permanent rotation upgrade (max level 3 for 100% improvement)
                        if (ship.rotationLevel < UPGRADE_LIMITS.rotationLevel) {
                            ship.rotationLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'bouncing':
                        // Enable bouncing bullets (permanent, one-time toggle)
                        if (!ship.bulletBounce) {
                            ship.bulletBounce = true;
                        }
                        break;
                }
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, weaponLevel = 0, ownerId = null, canBounce = false) {
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(vx, vy);
                this.weaponLevel = weaponLevel;
                this.upgradeLevel = weaponLevel; // Track specific upgrade level (0-2)
                this.bounceCount = 0;
                this.hasHitWall = false;
                this.ownerId = ownerId;
                this.canBounce = canBounce;

                // 3-level bullet progression system (Red, Yellow, Green)
                const bulletConfigs = [
                    // Level 0: Red
                    { color: '#ff4444', damage: 110, lifetime: 6.0, name: 'Red' },
                    // Level 1: Yellow
                    { color: '#ffff44', damage: 130, lifetime: 9.0, name: 'Yellow' },
                    // Level 2: Green
                    { color: '#44ff44', damage: 150, lifetime: 15.0, name: 'Green' }
                ];

                const config = bulletConfigs[Math.min(weaponLevel, 2)] || bulletConfigs[0];
                this.color = config.color;
                this.lifetime = config.lifetime;
                this.maxLifetime = this.lifetime;
                this.bulletName = config.name;
                this.maxBounces = 1;
                this.size = 4; // Bullet collision size

                // Apply ship-specific damage multiplier
                const shipConfig = window.shipConfig ? window.shipConfig.getConfig(1) : { bulletDamageMultiplier: 1.0 };
                this.damage = config.damage * shipConfig.bulletDamageMultiplier;
            }

            update(deltaTime) {
                this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));
                this.lifetime -= deltaTime;

                // Handle bouncing off world edges
                let shouldBounce = false;
                if (this.pos.x < 0) {
                    this.pos.x = 0;
                    this.vel.x = Math.abs(this.vel.x);
                    shouldBounce = true;
                } else if (this.pos.x > WORLD_WIDTH) {
                    this.pos.x = WORLD_WIDTH;
                    this.vel.x = -Math.abs(this.vel.x);
                    shouldBounce = true;
                }

                if (this.pos.y < PLAYFIELD_TOP) {
                    this.pos.y = PLAYFIELD_TOP;
                    this.vel.y = Math.abs(this.vel.y);
                    shouldBounce = true;
                } else if (this.pos.y > PLAYFIELD_BOTTOM) {
                    this.pos.y = PLAYFIELD_BOTTOM;
                    this.vel.y = -Math.abs(this.vel.y);
                    shouldBounce = true;
                }

                if (shouldBounce) {
                    if (this.canBounce && this.bounceCount < this.maxBounces) {
                        this.bounceCount++;
                        // Reduce velocity slightly on bounce
                        this.vel.scale(0.9);
                    } else {
                        this.lifetime = 0; // Destroy bullet if it can't bounce
                    }
                }
            }

            expired() {
                return this.lifetime <= 0;
            }

            draw(ctx, viewport) {
                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                const alpha = this.lifetime / this.maxLifetime;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Draw bullet based on upgrade level and bounce capability (3-level system)
                switch(this.upgradeLevel) {
                    case 0: // Level 0: Red
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.1, 0, Math.PI * 2); // 3 * 0.7 = 2.1
                        ctx.fill();
                        // Add white border if bouncing enabled
                        if (this.canBounce) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(screenPos.x, screenPos.y, 2.8, 0, Math.PI * 2); // 4 * 0.7 = 2.8
                            ctx.stroke();
                        }
                        break;

                    case 1: // Level 1: Yellow
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.8, 0, Math.PI * 2); // 4 * 0.7 = 2.8
                        ctx.fill();
                        // Add orange border if bouncing enabled
                        if (this.canBounce) {
                            ctx.strokeStyle = '#ff8800';
                            ctx.lineWidth = 1.4; // 2 * 0.7 = 1.4
                            ctx.beginPath();
                            ctx.arc(screenPos.x, screenPos.y, 3.5, 0, Math.PI * 2); // 5 * 0.7 = 3.5
                            ctx.stroke();
                        }
                        break;

                    case 2: // Level 2: Green
                        // Glow effect if bouncing
                        if (this.canBounce) {
                            ctx.shadowColor = this.color;
                            ctx.shadowBlur = 5.6; // 8 * 0.7 = 5.6
                        }
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 3.5, 0, Math.PI * 2); // 5 * 0.7 = 3.5
                        ctx.fill();

                        // Reset shadow and add cyan border if bouncing
                        if (this.canBounce) {
                            ctx.shadowBlur = 0;
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 1.4; // 2 * 0.7 = 1.4
                            ctx.beginPath();
                            ctx.arc(screenPos.x, screenPos.y, 4.2, 0, Math.PI * 2); // 6 * 0.7 = 4.2
                            ctx.stroke();
                        }
                        break;
                }

                // Add bounce indicator for bouncing bullets (30% smaller)
                if (this.bounceCount > 0) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, 5.6, 0, Math.PI * 2); // 8 * 0.7 = 5.6
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }
        }

        // Bomb class
        class Bomb {
            constructor(x, y, vx, vy, bombType = 'red', weaponLevel = 0, ownerId = null, options = {}) {
                options = options || {};
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(vx, vy);
                this.bombType = bombType;
                this.weaponLevel = weaponLevel;
                this.exploded = false;
                this.shrapnelPieces = [];
                this.bounceCount = 0;
                this.maxBounces = (bombType === 'yellow' && weaponLevel >= 2) ? 1 : 0;
                this.wallBounceCount = 0; // Track wall bounces separately
                this.maxWallBounces = 1; // All bombs can only bounce once off walls
                this.ownerId = ownerId;
                this.age = 0; // Track how long the bomb has been active
                this.armDelay = 0.35; // Give the bomb time to leave the firing ship
                this.isMine = !!options.isMine;
                this.isDislodged = !!options.isDislodged;
                this.createdAt = Number.isFinite(options.createdAt) ? options.createdAt : Date.now();
                this.id = typeof options.id === 'string' ? options.id : null;
                this.repelGrace = Number.isFinite(options.repelGrace) ? options.repelGrace : 0;

                // Bomb properties based on type
                const bombConfig = {
                    red: {
                        color: '#ff6666',
                        size: 6,
                        shrapnelCount: 8,
                        shrapnelSpeed: 200,
                        explosionRadius: 130,
                        damage: 450
                    },
                    yellow: {
                        color: '#ffff66',
                        size: 8,
                        shrapnelCount: 12,
                        shrapnelSpeed: 250,
                        explosionRadius: 140,
                        damage: 650
                    }
                };

                const config = bombConfig[bombType] || bombConfig.red;
                this.color = config.color;
                this.size = config.size;
                this.shrapnelCount = config.shrapnelCount;
                this.shrapnelSpeed = config.shrapnelSpeed;
                this.explosionRadius = config.explosionRadius;
                this.damage = config.damage;
            }

            update(deltaTime) {
                if (!this.exploded) {
                    this.age += deltaTime;
                    if (this.repelGrace > 0) {
                        this.repelGrace = Math.max(0, this.repelGrace - deltaTime);
                    }
                    if (this.isMine && !this.isDislodged) {
                        this.vel.x = 0;
                        this.vel.y = 0;
                        return;
                    }

                    this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));
                    // Bombs don't expire on their own - they travel across the entire map

                    // Check for world edge collisions
                    let shouldBounce = false;
                    if (this.pos.x < 0) {
                        this.pos.x = 0;
                        this.vel.x = Math.abs(this.vel.x);
                        shouldBounce = true;
                    } else if (this.pos.x > WORLD_WIDTH) {
                        this.pos.x = WORLD_WIDTH;
                        this.vel.x = -Math.abs(this.vel.x);
                        shouldBounce = true;
                    }

                    if (this.pos.y < PLAYFIELD_TOP) {
                        this.pos.y = PLAYFIELD_TOP;
                        this.vel.y = Math.abs(this.vel.y);
                        shouldBounce = true;
                    } else if (this.pos.y > PLAYFIELD_BOTTOM) {
                        this.pos.y = PLAYFIELD_BOTTOM;
                        this.vel.y = -Math.abs(this.vel.y);
                        shouldBounce = true;
                    }

                    if (shouldBounce) {
                        if (this.bounceCount < this.maxBounces) {
                            this.bounceCount++;
                            // Reduce velocity slightly on bounce
                            this.vel.scale(0.9);
                        } else {
                            this.explode();
                        }
                    }
                } else {
                    // Update shrapnel
                    for (const shrapnel of this.shrapnelPieces) {
                        shrapnel.pos.add(new Vector2D(shrapnel.vel.x * deltaTime, shrapnel.vel.y * deltaTime));
                        shrapnel.lifetime -= deltaTime;
                    }
                    // Remove expired shrapnel
                    this.shrapnelPieces = this.shrapnelPieces.filter(s => s.lifetime > 0);
                }
            }

            explode() {
                if (this.exploded) return;
                this.exploded = true;

                // Create shrapnel pieces
                for (let i = 0; i < this.shrapnelCount; i++) {
                    const angle = (i / this.shrapnelCount) * Math.PI * 2;
                    const speed = this.shrapnelSpeed + (Math.random() - 0.5) * 100;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    this.shrapnelPieces.push({
                        pos: new Vector2D(this.pos.x, this.pos.y),
                        vel: new Vector2D(vx, vy),
                        lifetime: 1.5,
                        maxLifetime: 1.5,
                        color: this.color
                    });
                }
            }

            expired() {
                return this.exploded && this.shrapnelPieces.length === 0;
            }

            draw(ctx, viewport) {
                if (!this.exploded) {
                    const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                    const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                    const baseRadius = this.size;
                    const minRadius = Math.max(2, baseRadius * 0.4);
                    const radius = speed > 600 ? Math.max(minRadius, baseRadius * (800 / (speed + 400))) : baseRadius;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw shrapnel
                    for (const shrapnel of this.shrapnelPieces) {
                        const screenPos = viewport.worldToScreen(shrapnel.pos.x, shrapnel.pos.y);
                        const alpha = shrapnel.lifetime / shrapnel.maxLifetime;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = shrapnel.color;
                        ctx.fillRect(screenPos.x - 1, screenPos.y - 1, 2, 2);
                    }
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Wall class - blocks bullets and bounces bombs
        class Wall {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.bricks = [];
                this.brickSize = 20;
                this.brickCount = 6;
                this.lifetime = 300; // Wall lasts roughly five minutes
                this.maxLifetime = this.lifetime;

                const wallAngle = Number.isFinite(angle) ? angle : 0;
                const lateralX = Math.cos(wallAngle);
                const lateralY = Math.sin(wallAngle);

                for (let i = 0; i < this.brickCount; i++) {
                    const offset = (i + 1) * this.brickSize;
                    this.bricks.push({
                        x: x + lateralX * offset,
                        y: y + lateralY * offset
                    });
                }
            }

            update(deltaTime) {
                this.lifetime -= deltaTime;
            }

            expired() {
                return this.lifetime <= 0;
            }

            checkBulletCollision(bullet) {
                for (let brick of this.bricks) {
                    const dx = bullet.pos.x - brick.x;
                    const dy = bullet.pos.y - brick.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.brickSize / 2 + bullet.size / 2) {
                        const angle = Math.atan2(dy, dx);
                        const speed = Math.sqrt(bullet.vel.x * bullet.vel.x + bullet.vel.y * bullet.vel.y);
                        bullet.vel.x = Math.cos(angle) * speed;
                        bullet.vel.y = Math.sin(angle) * speed;

                        bullet.pos.x = brick.x + Math.cos(angle) * (this.brickSize / 2 + bullet.size / 2 + 5);
                        bullet.pos.y = brick.y + Math.sin(angle) * (this.brickSize / 2 + bullet.size / 2 + 5);

                        bullet.bounceCount = (bullet.bounceCount || 0) + 1;
                        bullet.hasHitWall = true;
                        bullet.vel.scale(0.8);

                        return false;
                    }
                }
                return false;
            }

            checkBombCollision(bomb) {
                for (let brick of this.bricks) {
                    const dx = bomb.pos.x - brick.x;
                    const dy = bomb.pos.y - brick.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.brickSize / 2 + bomb.size) {
                        const angle = Math.atan2(dy, dx);
                        const speed = Math.sqrt(bomb.vel.x * bomb.vel.x + bomb.vel.y * bomb.vel.y);
                        bomb.vel.x = Math.cos(angle) * speed;
                        bomb.vel.y = Math.sin(angle) * speed;

                        bomb.pos.x = brick.x + Math.cos(angle) * (this.brickSize / 2 + bomb.size + 5);
                        bomb.pos.y = brick.y + Math.sin(angle) * (this.brickSize / 2 + bomb.size + 5);

                        bomb.wallBounceCount = (bomb.wallBounceCount || 0) + 1;
                        return true;
                    }
                }
                return false;
            }

            checkShipCollision(ship) {
                for (let brick of this.bricks) {
                    const dx = ship.pos.x - brick.x;
                    const dy = ship.pos.y - brick.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const shipRadius = ship.hitRadius !== undefined ? ship.hitRadius : ship.size;
                    if (distance < this.brickSize / 2 + shipRadius) {
                        const angle = Math.atan2(dy, dx);
                        const pushDistance = this.brickSize / 2 + shipRadius + 2;

                        ship.pos.x = brick.x + Math.cos(angle) * pushDistance;
                        ship.pos.y = brick.y + Math.sin(angle) * pushDistance;

                        const velAngle = Math.atan2(ship.vel.y, ship.vel.x);
                        const angleDiff = Math.abs(velAngle - (angle + Math.PI));

                        if (angleDiff < Math.PI / 2) {
                            ship.vel.scale(0.3);
                        }

                        return true;
                    }
                }
                return false;
            }

            draw(ctx, viewport) {
                for (let brick of this.bricks) {
                    if (!brick.destroyed) {
                        const screenPos = viewport.worldToScreen(brick.x, brick.y);
                        const alpha = this.lifetime / this.maxLifetime;

                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#666666';
                        ctx.fillRect(screenPos.x - this.brickSize/2, screenPos.y - this.brickSize/2,
                                   this.brickSize, this.brickSize);

                        // Border
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenPos.x - this.brickSize/2, screenPos.y - this.brickSize/2,
                                     this.brickSize, this.brickSize);
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        // Viewport class for camera/scrolling
        class Viewport {
            constructor(canvasWidth, canvasHeight) {
                this.width = canvasWidth;
                this.height = canvasHeight;
                this.x = 0; // World position of viewport center
                this.y = 0;
                this.zoom = 1;

                // World size (much larger than viewport)
                this.worldWidth = WORLD_WIDTH;
                this.worldHeight = WORLD_HEIGHT;
            }

            follow(entity) {
                // Center viewport on entity
                this.x = entity.pos.x;
                this.y = entity.pos.y;

                // Keep viewport within world bounds, but prioritize showing the entity
                // If world is smaller than viewport, center the world in viewport
                if (this.worldWidth < this.width) {
                    this.x = this.worldWidth / 2;
                } else {
                    this.x = Math.max(this.width / 2, Math.min(this.worldWidth - this.width / 2, this.x));
                }

                if (this.worldHeight < this.height) {
                    this.y = this.worldHeight / 2;
                } else {
                    this.y = Math.max(this.height / 2, Math.min(this.worldHeight - this.height / 2, this.y));
                }
            }

            worldToScreen(worldX, worldY) {
                return {
                    x: worldX - this.x + this.width / 2,
                    y: worldY - this.y + this.height / 2
                };
            }

            screenToWorld(screenX, screenY) {
                return {
                    x: screenX + this.x - this.width / 2,
                    y: screenY + this.y - this.height / 2
                };
            }

            isVisible(entity) {
                const margin = 100; // Extra margin for smooth appearance
                return entity.pos.x > this.x - this.width / 2 - margin &&
                       entity.pos.x < this.x + this.width / 2 + margin &&
                       entity.pos.y > this.y - this.height / 2 - margin &&
                       entity.pos.y < this.y + this.height / 2 + margin;
            }
        }

        // Minimap class for real-time updates
        class Minimap {
            constructor(canvasId, worldWidth, worldHeight) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.worldWidth = worldWidth;
                this.worldHeight = worldHeight;
                this.radarRadius = this.canvas.width / 2;

                // Turn off smoothing for crisp display
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.mozImageSmoothingEnabled = false;
                this.ctx.webkitImageSmoothingEnabled = false;
                this.ctx.msImageSmoothingEnabled = false;

                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            }

            // Convert world coordinates to minimap coordinates
            worldToMinimap(worldX, worldY) {
                const scaleX = (this.canvas.width - 4) / this.worldWidth;  // -4 for border padding
                const scaleY = (this.canvas.height - 4) / this.worldHeight;
                const scale = Math.min(scaleX, scaleY);

                return {
                    x: (worldX / this.worldWidth) * (this.canvas.width - 4) + 2,
                    y: (worldY / this.worldHeight) * (this.canvas.height - 4) + 2
                };
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw background circle
                this.ctx.fillStyle = 'rgba(0, 50, 50, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radarRadius - 2, 0, Math.PI * 2);
                this.ctx.fill();
            }

            drawPlayer(worldX, worldY, color = '#00ff00', isLocal = false) {
                const pos = this.worldToMinimap(worldX, worldY);

                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, isLocal ? 3 : 2, 0, Math.PI * 2);
                this.ctx.fill();

                if (isLocal) {
                    // Add a ring around local player
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }

            drawSafeZone(worldX, worldY, radius) {
                const center = this.worldToMinimap(worldX, worldY);
                const mapRadius = (radius / this.worldWidth) * (this.canvas.width - 4);

                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, mapRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]); // Reset dash
            }

            drawBomb(worldX, worldY, isMine = false) {
                const pos = this.worldToMinimap(worldX, worldY);

                this.ctx.fillStyle = isMine ? '#ff0000' : '#ff8800';
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, isMine ? 2 : 1.5, 0, Math.PI * 2);
                this.ctx.fill();
            }

            drawWall(bricks) {
                this.ctx.fillStyle = '#888888';
                bricks.forEach(brick => {
                    const pos = this.worldToMinimap(brick.x, brick.y);
                    this.ctx.fillRect(pos.x - 1, pos.y - 1, 2, 2);
                });
            }

            update(game) {
                this.clear();

                // Draw safe zone
                if (game.safeZone) {
                    this.drawSafeZone(game.safeZone.x, game.safeZone.y, game.safeZone.radius);
                }

                // Draw walls
                if (game.walls) {
                    game.walls.forEach(wall => {
                        if (wall && wall.bricks) {
                            this.drawWall(wall.bricks);
                        }
                    });
                }

                // Draw bombs and mines
                if (game.bombs) {
                    game.bombs.forEach(bomb => {
                        if (bomb && bomb.pos) {
                            this.drawBomb(bomb.pos.x, bomb.pos.y, bomb.isMine || false);
                        }
                    });
                }

                // Draw local player
                if (game.playerShip && game.playerShip.pos) {
                    this.drawPlayer(game.playerShip.pos.x, game.playerShip.pos.y, '#00ff00', true);
                }

                // Draw remote players
                if (game.otherPlayers) {
                    game.otherPlayers.forEach(player => {
                        if (player && player.pos) {
                            this.drawPlayer(player.pos.x, player.pos.y, '#ffff00', false);
                        }
                    });
                }
            }
        }

        // Main game class
        class SubspaceGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                // Turn off smoothing for crisp pixel art
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.mozImageSmoothingEnabled = false;
                this.ctx.webkitImageSmoothingEnabled = false;
                this.ctx.msImageSmoothingEnabled = false;

                // Load simple ship sprite (like Valor does)
                this.shipImage = new Image();
                this.shipLoaded = false;
                this.processedShipCanvas = null;
                this.shipImage.onload = () => {
                    // Create an offscreen canvas the same size as shipImage
                    const off = document.createElement('canvas');
                    off.width = this.shipImage.width;
                    off.height = this.shipImage.height;
                    const offCtx = off.getContext('2d');

                    // Draw the sprite sheet into it
                    offCtx.drawImage(this.shipImage, 0, 0);

                    // Access pixel data and make black pixels transparent
                    const imgData = offCtx.getImageData(0, 0, off.width, off.height);
                    const data = imgData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        // treat very dark pixels as transparent
                        if (r < 16 && g < 16 && b < 16) {
                            data[i + 3] = 0;
                        }
                    }
                    offCtx.putImageData(imgData, 0, 0);

                    // Use the processed canvas as the sprite source
                    this.processedShipCanvas = off;
                    this.shipLoaded = true;
                    console.log('Processed ship sprite loaded successfully');
                };
                this.shipImage.src = 'ships.png'; // Use the full 8-ship sprite sheet

                // Ship config for 8 ship types, 36 rotation frames per ship in a grid
                this.shipFrameWidth = 40;   // Each frame is 40px wide
                this.shipFrameHeight = 36;  // Each frame is 36px tall
                this.rotationFrames = 36;   // 9 columns × 4 rows = 36 rotation frames per ship

                // Ship types for the HUD
                this.shipTypes = {
                    1: { name: 'Warbird' },
                    2: { name: 'Javelin' },
                    3: { name: 'Spider' },
                    4: { name: 'Leviathan' },
                    5: { name: 'Terrier' },
                    6: { name: 'Weasel' },
                    7: { name: 'Lancaster' },
                    8: { name: 'Shark' }
                };

                // Game state
                this.running = true;
                this.lastTime = 0;

                // Multiplayer state
                this.isMultiplayer = false;
                this.playerId = null;
                this.otherPlayers = new Map();
                this.ws = null;
                this.lastDamageSource = null;
                this.shipSelectionEnabled = true;

                // Viewport for camera system
                this.viewport = new Viewport(this.canvas.width, this.canvas.height);

                // Initialize minimap
                this.minimap = new Minimap('radarCanvas', this.viewport.worldWidth, this.viewport.worldHeight);

                // Create player ship in world coordinates
                this.playerShip = new Ship(this.viewport.worldWidth / 2, this.viewport.worldHeight / 2, true);

                // Other ships for testing
                this.ships = [this.playerShip];

                // Power-ups system
                this.powerUps = [];
                this.powerUpSpawnTimer = 0;
                this.powerUpSpawnInterval = 4; // Spawn every 4 seconds (100% more frequent)
                this.powerUpsCollected = 0; // Player's bounty/score
                this.playerBounties = new Map();
                this.safeZone = {
                    x: this.viewport.worldWidth / 2,
                    y: this.viewport.worldHeight / 2,
                    radius: 250
                };
                this.lastBroadcastState = {
                    time: 0,
                    x: null,
                    y: null,
                    rotation: null
                };

                // Weapons system
                this.bombs = [];
                this.mineLimit = 5;
                this.entityIdCounter = 1;
                this.repelRadius = 2200;
                this.repelForce = 1800;
                this.repelShipSpeedMultiplier = 4.5;
                this.repelBombSpeedCap = 900;
                this.repelBulletSpeedCap = 1100;
                this.repelShipBoostDuration = 1.2;
                this.repelBombSpeedCap = 900;
                this.repelBulletSpeedCap = 1100;
                this.repelShipBoostDuration = 1.2;

                // Walls system
                this.walls = [];

                // Bounty timer system
                this.bountyTimer = 0;
                this.bountyInterval = 60; // 1 minute in seconds
                this.bountyIncrease = 50;
                this.killBountyBonus = 250; // Bonus applied to killer bounty in multiplayer

                // Input state
                this.keys = {};
                this.input = {
                    left: false,
                    right: false,
                    thrust: false,
                    reverse: false,
                    brake: false,
                    boost: false,
                    fire: false,
                    deployMine: false,
                    bomb: false,
                    deployWall: false,
                    burst: false
                };

                this.setupEventListeners();

                // Spawn initial power-ups
                this.spawnInitialPowerUps();

                // Make game available globally for bomb firing
                window.game = this;

                // Setup config panel
                this.setupConfigPanel();

                this.updateLocalBounty(false);

                this.gameLoop();
            }

            connectToMultiplayer() {
                const statusEl = document.getElementById('multiplayerStatus');
                const btnEl = document.getElementById('multiplayerBtn');

                statusEl.textContent = 'Connecting...';
                btnEl.disabled = true;

                this.ws = new WebSocket('wss://172.239.66.45:8443');
                this.isMultiplayer = true;

                this.ws.onopen = () => {
                    console.log('Connected to multiplayer server');
                    statusEl.textContent = 'Connected! Waiting for players...';
                    btnEl.textContent = 'CONNECTED';
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleMultiplayerMessage(data);

                    if (data.type === 'init') {
                        statusEl.textContent = `Connected as ${data.playerId}`;
                    }
                };

                this.ws.onclose = () => {
                    console.log('Disconnected from multiplayer server');
                    this.isMultiplayer = false;
                    this.otherPlayers.clear();
                    this.playerBounties.clear();
                    this.playerId = null;
                    this.updateLocalBounty(false);
                    statusEl.textContent = 'Disconnected';
                    btnEl.textContent = 'JOIN MULTIPLAYER';
                    btnEl.disabled = false;
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Connection failed';
                    btnEl.disabled = false;
                };
            }

            handleMultiplayerMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.playerId = data.playerId;
                        if (typeof data.shipSelectionEnabled === 'boolean') {
                            this.shipSelectionEnabled = data.shipSelectionEnabled;
                        }
                        this.playerBounties.delete('local');
                        this.setPlayerBounty(this.playerId, this.powerUpsCollected);
                        if (data.world) {
                            if (Number.isFinite(data.world.width)) {
                                this.viewport.worldWidth = data.world.width;
                            }
                            if (Number.isFinite(data.world.height)) {
                                this.viewport.worldHeight = data.world.height;
                            }
                        }
                        if (data.safeZone && Number.isFinite(data.safeZone.x) && Number.isFinite(data.safeZone.y) && Number.isFinite(data.safeZone.radius)) {
                            this.safeZone = {
                                x: data.safeZone.x,
                                y: data.safeZone.y,
                                radius: data.safeZone.radius
                            };
                        }
                        data.players.forEach(player => {
                            if (player.id !== this.playerId) {
                                const shipType = Number.isFinite(player.shipType) ? player.shipType : 1;
                                this.otherPlayers.set(player.id, new Ship(player.x, player.y, false, shipType));
                                const existingBounty = Number.isFinite(player.bounty) ? player.bounty : 0;
                                this.setPlayerBounty(player.id, existingBounty);
                            }
                        });
                        this.updateLocalBounty(true);
                        this.broadcastPlayerState(true);
                        break;

                    case 'playerJoined':
                        if (data.player.id !== this.playerId) {
                            const shipType = Number.isFinite(data.player.shipType) ? data.player.shipType : 1;
                            this.otherPlayers.set(data.player.id, new Ship(data.player.x, data.player.y, false, shipType));
                            const joinedBounty = Number.isFinite(data.player.bounty) ? data.player.bounty : 0;
                            this.setPlayerBounty(data.player.id, joinedBounty);
                        }
                        break;

                    case 'playerLeft':
                        this.otherPlayers.delete(data.playerId);
                        this.playerBounties.delete(data.playerId);
                        break;

                    case 'playerMove':
                        // Legacy compatibility (older servers)
                        this.updateRemotePlayer(data.playerId, data);
                        break;
                    case 'playerUpdate':
                        if (data.id !== this.playerId) {
                            this.updateRemotePlayer(data.id, data);
                        }
                        break;

                    case 'bullet':
                        if (data.playerId !== this.playerId) {
                            const bullet = new Bullet(
                                data.x,
                                data.y,
                                data.vx,
                                data.vy,
                                data.weaponLevel || 0,
                                data.playerId,
                                data.canBounce || false
                            );
                            this.playerShip.bullets.push(bullet);
                        }
                        break;

                    case 'bomb':
                        if (data.playerId !== this.playerId) {
                            const bomb = new Bomb(
                                data.x,
                                data.y,
                                data.vx,
                                data.vy,
                                typeof data.bombType === 'string' ? data.bombType : (typeof data.color === 'string' && data.color.indexOf('ff') >= 0 ? 'yellow' : 'red'),
                                data.weaponLevel || 0,
                                data.playerId,
                                {
                                    isMine: !!data.isMine,
                                    createdAt: data.createdAt,
                                    id: data.bombId
                                }
                            );
                            this.bombs.push(bomb);
                        }
                        break;
                    case 'playerWarped':
                        if (data && data.playerId) {
                            const warpPlayerId = data.playerId;
                            const warpX = Number(data.x);
                            const warpY = Number(data.y);
                            if (Number.isFinite(warpX) && Number.isFinite(warpY)) {
                                this.performLocalWarp(warpPlayerId);
                                const ship = warpPlayerId === this.playerId ? this.playerShip : this.otherPlayers.get(warpPlayerId);
                                if (ship) {
                                    ship.pos.x = warpX;
                                    ship.pos.y = warpY;
                                }
                            }
                            if (warpPlayerId === this.playerId) {
                                const ship = this.playerShip;
                                if (ship && Number.isFinite(Number(data.energy))) {
                                    ship.energy = Number(data.energy);
                                }
                                if (ship && Number.isFinite(Number(data.maxEnergy))) {
                                    ship.maxEnergy = Number(data.maxEnergy);
                                }
                                this.updateHUD();
                            }
                        }
                        break;
                    case 'warpDenied':
                        // Ignore for now or display notice
                        break;

                    case 'wall':
                        if (data.playerId !== this.playerId) {
                            data.bricks.forEach(brick => {
                                this.walls.push(new Wall(brick.x, brick.y));
                            });
                        }
                        break;

                    case 'burst':
                        if (data && data.playerId !== this.playerId) {
                            const burstX = Number(data.x);
                            const burstY = Number(data.y);
                            if (Number.isFinite(burstX) && Number.isFinite(burstY)) {
                                this.triggerRepel(burstX, burstY, data.playerId || null, false, {
                                    radius: Number(data.radius),
                                    force: Number(data.force),
                                    shipSpeedMultiplier: Number(data.shipSpeedMultiplier),
                                    bombSpeedCap: Number(data.bombSpeedCap),
                                    bulletSpeedCap: Number(data.bulletSpeedCap),
                                    shipBoostDuration: Number(data.shipBoostDuration)
                                });
                            }
                        }
                        break;
                    case 'playerDamage':
                        if (data.targetId === this.playerId) {
                            this.damagePlayer(
                                data.bulletLevel || data.bulletType || 0,
                                data.attackerId || null
                            );
                        }
                        break;
                    case 'bombDamage':
                        if (data.targetId === this.playerId) {
                            const localOwnerId = this.playerId || 'local';
                            if (data.isMine && data.attackerId && data.attackerId === localOwnerId) {
                                break;
                            }
                            this.applyDamageToPlayerShip(
                                data.damage || 0,
                                {
                                    attackerId: data.attackerId || null,
                                    weapon: 'bomb',
                                    metadata: { bombType: data.bombType || null }
                                }
                            );
                        }
                        break;
                    case 'bombExplosion':
                        // Create visual explosion effect and shrapnel
                        this.createRemoteBombExplosion(data.x, data.y, data.bombType);
                        break;
                    case 'mineDislodged':
                        if (data && typeof data.bombId === 'string') {
                            const bomb = this.bombs.find(b => b && b.id === data.bombId);
                            if (bomb) {
                                bomb.isMine = false;
                                bomb.isDislodged = true;
                                bomb.repelGrace = Math.max(bomb.repelGrace || 0, 0.4);
                            }
                        }
                        break;
                    case 'playerKilled':
                        if (Number.isFinite(data.victimBounty)) {
                            this.setPlayerBounty(data.victimId, data.victimBounty);
                        }
                        if (Number.isFinite(data.killerBounty)) {
                            this.setPlayerBounty(data.killerId, data.killerBounty);
                        }
                        if (this.isLocalPlayer(data.killerId) && Number.isFinite(data.killerBounty)) {
                            this.powerUpsCollected = Math.max(0, Math.floor(data.killerBounty));
                            this.updateLocalBounty(false);
                            this.updateHUD();
                        }
                        if (!this.isLocalPlayer(data.victimId)) {
                            const victimShip = this.otherPlayers.get(data.victimId);
                            if (victimShip) {
                                victimShip.die();
                            }
                        }
                        if (!this.isLocalPlayer(data.victimId)) {
                            this.showKillMessage(
                                this.buildKillMessage(
                                    data.victimId,
                                    data.killerId,
                                    data.victimBounty,
                                    data.killerBounty
                                )
                            );
                        }
                        break;
                    case 'bountyUpdate':
                        if (!this.isLocalPlayer(data.playerId) && Number.isFinite(data.bounty)) {
                            this.setPlayerBounty(data.playerId, data.bounty);
                        }
                        break;
                    case 'playerDisconnected':
                        this.otherPlayers.delete(data.id);
                        this.playerBounties.delete(data.id);
                        break;
                    case 'shipChange':
                        if (data.playerId === this.playerId) {
                            this.playerShip.shipType = data.shipType;
                            this.playerShip.updateStatsFromLevels();
                            this.updateHUD();
                        } else {
                            const ship = this.otherPlayers.get(data.playerId);
                            if (ship && Number.isFinite(data.shipType)) {
                                ship.shipType = data.shipType;
                                ship.updateStatsFromLevels();
                            }
                        }
                        break;
                }
            }

            sendMultiplayerMessage(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }

            broadcastPlayerState(force = false) {
                if (!this.isMultiplayer) {
                    return;
                }

                const now = (typeof performance !== 'undefined' && performance.now)
                    ? performance.now()
                    : Date.now();
                const last = this.lastBroadcastState;
                const lastTime = last.time || 0;
                const lastX = last.x != null ? last.x : this.playerShip.pos.x;
                const lastY = last.y != null ? last.y : this.playerShip.pos.y;
                const lastRotation = last.rotation != null ? last.rotation : this.playerShip.angle;

                const dx = Math.abs(this.playerShip.pos.x - lastX);
                const dy = Math.abs(this.playerShip.pos.y - lastY);
                const dRotation = Math.abs(this.playerShip.angle - lastRotation);
                const dt = now - lastTime;

                const positionChanged = dx > 2 || dy > 2;
                const rotationChanged = dRotation > 0.02;
                const timeElapsed = dt > 120;

                if (!force && !positionChanged && !rotationChanged && !timeElapsed) {
                    return;
                }

                const shipType = Math.min(8, Math.max(1, Math.floor(this.playerShip.shipType || 1)));

                this.sendMultiplayerMessage({
                    type: 'playerUpdate',
                    x: this.playerShip.pos.x,
                    y: this.playerShip.pos.y,
                    rotation: this.playerShip.angle,
                    thrust: !!(this.input && this.input.thrust),
                    shipType,
                    energy: this.playerShip.energy,
                    maxEnergy: this.playerShip.maxEnergy
                });

                this.lastBroadcastState = {
                    time: now,
                    x: this.playerShip.pos.x,
                    y: this.playerShip.pos.y,
                    rotation: this.playerShip.angle
                };
            }

            updateRemotePlayer(playerId, data) {
                const player = this.otherPlayers.get(playerId);
                if (!player) {
                    return;
                }

                if (Number.isFinite(data.x)) {
                    const marginX = player.hitRadius !== undefined ? player.hitRadius : (player.size || 0);
                    player.pos.x = Math.max(marginX, Math.min(WORLD_WIDTH - marginX, data.x));
                }
                if (Number.isFinite(data.y)) {
                    const margin = player.hitRadius !== undefined ? player.hitRadius : (player.size || 0);
                    const minY = PLAYFIELD_TOP + margin;
                    const maxY = PLAYFIELD_BOTTOM - margin;
                    player.pos.y = Math.max(minY, Math.min(maxY, data.y));
                }
                if (Number.isFinite(data.rotation)) {
                    player.angle = data.rotation;
                }
                if (Number.isFinite(data.energy)) {
                    player.energy = data.energy;
                }
                if (Number.isFinite(data.maxEnergy)) {
                    player.maxEnergy = data.maxEnergy;
                }
                if (Number.isFinite(data.shipType) && this.shipSelectionEnabled) {
                    player.shipType = data.shipType;
                    player.updateStatsFromLevels();
                }
            }

            checkBulletPlayerCollision(bullet, player) {
                if (!bullet || !player || !bullet.pos || !player.pos) {
                    return false;
                }
                const dx = bullet.pos.x - player.pos.x;
                const dy = bullet.pos.y - player.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const playerHitRadius = player.hitRadius !== undefined ? player.hitRadius : player.size;
                const bulletRadius = (bullet.size || 4) * 0.5;
                return distance < bulletRadius + playerHitRadius;
            }

            applyDamageToPlayerShip(damage, source = null) {
                if (!damage) {
                    return;
                }

                if (source && source.attackerId) {
                    const timestamp = (typeof performance !== 'undefined' && performance.now)
                        ? performance.now()
                        : Date.now();
                    this.lastDamageSource = {
                        attackerId: source.attackerId,
                        weapon: source.weapon || 'unknown',
                        metadata: source.metadata || {},
                        timestamp
                    };
                }

                if (this.isInSafeZone(this.playerShip.pos.x, this.playerShip.pos.y)) {
                    return;
                }

                if (this.playerShip.isShieldActive()) {
                    return;
                }

                this.playerShip.energy = Math.max(0, this.playerShip.energy - damage);

                if (this.playerShip.energy <= 0) {
                    const killerInfo = this.lastDamageSource;
                    this.handlePlayerDeath(killerInfo);
                    this.playerShip.die();
                    this.broadcastPlayerState(true);
                    this.lastDamageSource = null;
                }
            }

            damagePlayer(bulletLevel, attackerId = null) {
                const damage = this.getBulletDamage(Math.min(Math.max(bulletLevel, 0), 2));

                console.log(`Hit by level ${bulletLevel} bullet for ${damage} damage`);
                this.applyDamageToPlayerShip(damage, {
                    attackerId,
                    weapon: 'bullet',
                    metadata: { bulletLevel }
                });
            }

            sendPlayerDamage(playerId, bullet) {
                if (!this.isMultiplayer) {
                    return;
                }

                const target = this.otherPlayers.get(playerId);
                if (target && this.isInSafeZone(target.pos.x, target.pos.y)) {
                    return;
                }
                if (this.safeZone && this.isInSafeZone(this.playerShip.pos.x, this.playerShip.pos.y)) {
                    return;
                }

                const payload = {
                    type: 'playerDamage',
                    targetId: playerId,
                    attackerId: this.playerId,
                    bulletLevel: bullet?.weaponLevel ?? bullet?.upgradeLevel ?? 0
                };

                this.sendMultiplayerMessage(payload);
            }

            getBulletDamage(level) {
                const damageLevels = [110, 130, 150]; // 3 levels: Red, Yellow, Green
                const clampedIndex = Math.max(0, Math.min(level, damageLevels.length - 1));
                return damageLevels[clampedIndex];
            }

            handleBulletSelfDamage(bullet, targetShip) {
                if (!bullet) {
                    return;
                }

                const ownerId = bullet.ownerId;
                const isLocalOwner = ownerId === this.playerId || ownerId === 'local';
                if (!isLocalOwner) {
                    return;
                }

                const shooterShip = this.playerShip;
                if (!shooterShip || !targetShip) {
                    return;
                }

                const dx = shooterShip.pos.x - targetShip.pos.x;
                const dy = shooterShip.pos.y - targetShip.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const shooterRadius = shooterShip.hitRadius !== undefined ? shooterShip.hitRadius : shooterShip.size;
                const targetRadius = targetShip.hitRadius !== undefined ? targetShip.hitRadius : targetShip.size;
                const proximityThreshold = shooterRadius + targetRadius + 40;

                if (distance > proximityThreshold) {
                    return;
                }

                const bulletLevel = bullet.weaponLevel || bullet.upgradeLevel || 0;
                const damage = this.getBulletDamage(bulletLevel);

                this.applyDamageToPlayerShip(damage, {
                    attackerId: ownerId,
                    weapon: 'bullet',
                    metadata: {
                        bulletLevel: bulletLevel,
                        selfInflicted: true,
                        proximityDistance: Math.round(distance)
                    }
                });
            }

            handlePlayerDeath(killerInfo) {
                const killerId = killerInfo && killerInfo.attackerId ? killerInfo.attackerId : null;
                const victimBounty = this.powerUpsCollected;

                let killerBounty = null;
                const isValidKillOpponent = killerId && killerId !== this.playerId;
                if (isValidKillOpponent) {
                    const currentKillerBounty = this.getPlayerBounty(killerId);
                    const bonus = Number.isFinite(this.killBountyBonus) ? this.killBountyBonus : 0;
                    const base = Number.isFinite(currentKillerBounty) ? currentKillerBounty : 0;
                    const inherited = Number.isFinite(victimBounty) ? victimBounty : null;

                    killerBounty = base + bonus;
                    if (inherited !== null) {
                        killerBounty = Math.max(killerBounty, inherited);
                    }
                    killerBounty = Math.max(0, Math.floor(killerBounty));

                    this.setPlayerBounty(killerId, killerBounty);
                }

                this.setPlayerBounty(this.playerId, victimBounty);

                if (this.isMultiplayer) {
                    this.sendMultiplayerMessage({
                        type: 'playerKilled',
                        victimId: this.playerId,
                        killerId,
                        victimBounty,
                        killerBounty
                    });
                }

                this.updateLocalBounty();

                this.showKillMessage(this.buildKillMessage(this.playerId, killerId, victimBounty, killerBounty));
            }

            buildKillMessage(victimId, killerId, victimBounty = null, killerBounty = null) {
                const victimLabel = this.formatPlayerLabel(victimId, victimBounty);
                const killerLabel = killerId ? this.formatPlayerLabel(killerId, killerBounty) : 'the arena';

                const victimIsLocal = this.isLocalPlayer(victimId);
                const killerIsLocal = killerId ? this.isLocalPlayer(killerId) : false;

                if (victimIsLocal) {
                    return killerId
                        ? `${victimLabel} were killed by ${killerLabel}.`
                        : `${victimLabel} were destroyed.`;
                }

                if (killerIsLocal) {
                    return `${victimLabel} was killed by ${this.formatPlayerLabel(this.playerId, killerBounty)}.`;
                }

                if (killerId) {
                    return `${victimLabel} was killed by ${killerLabel}.`;
                }

                return `${victimLabel} was destroyed.`;
            }

            resolvePlayerName(playerId) {
                if (this.isLocalPlayer(playerId)) {
                    return 'You';
                }

                if (this.otherPlayers.has(playerId)) {
                    return `Pilot ${playerId}`;
                }

                if (!playerId || playerId === 'local') {
                    return 'Unknown';
                }

                return `Pilot ${playerId}`;
            }

            isLocalPlayer(playerId) {
                if (!this.playerId) {
                    return playerId === null || playerId === undefined || playerId === 'local';
                }
                return playerId === this.playerId;
            }

            setPlayerBounty(playerId, bounty) {
                if (playerId && Number.isFinite(bounty)) {
                    this.playerBounties.set(playerId, Math.max(0, Math.floor(bounty)));
                }
            }

            getPlayerBounty(playerId) {
                if (this.isLocalPlayer(playerId)) {
                    return this.powerUpsCollected;
                }
                if (playerId && this.playerBounties.has(playerId)) {
                    return this.playerBounties.get(playerId);
                }
                return null;
            }

            formatPlayerLabel(playerId, bountyOverride = null) {
                const name = this.resolvePlayerName(playerId);
                const bounty = (Number.isFinite(bountyOverride) ? Math.floor(bountyOverride) : this.getPlayerBounty(playerId));
                const bountyText = Number.isFinite(bounty) ? bounty : '?';
                return `${name} (B: ${bountyText})`;
            }

            updateLocalBounty(broadcast = true) {
                const bounty = this.powerUpsCollected;

                if (this.playerId) {
                    this.setPlayerBounty(this.playerId, bounty);
                    if (broadcast && this.isMultiplayer) {
                        this.sendMultiplayerMessage({
                            type: 'bountyUpdate',
                            playerId: this.playerId,
                            bounty
                        });
                    }
                } else {
                    this.playerBounties.set('local', bounty);
                }
            }

            showKillMessage(text) {
                if (!text) {
                    return;
                }

                const container = document.getElementById('messageContainer');
                if (!container) {
                    console.warn('Kill message container missing');
                    return;
                }

                const messageEl = document.createElement('div');
                messageEl.className = 'power-up-message';
                messageEl.style.color = '#ff4444';
                messageEl.style.borderColor = '#ff4444';
                messageEl.style.textShadow = '2px 2px 4px #000, 0 0 15px #ff4444';
                messageEl.innerHTML = `<div style="font-size: 24px;">${text}</div>`;

                container.appendChild(messageEl);

                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 3000);
            }

            checkBombPlayerProximity(bomb, player, radius, playerId = null) {
                if (bomb.age !== undefined && bomb.age < bomb.armDelay) {
                    return false;
                }

                if (bomb && bomb.isMine && bomb.ownerId && playerId && bomb.ownerId === playerId) {
                    return false;
                }

                if (bomb && Number.isFinite(bomb.repelGrace) && bomb.repelGrace > 0) {
                    return false;
                }

                const dx = bomb.pos.x - player.pos.x;
                const dy = bomb.pos.y - player.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < radius;
            }

            explodeBomb(bomb, bombIndex) {
                const explosionRadius = bomb.explosionRadius;
                const shrapnelCount = bomb.shrapnelCount || 8;

                // Remove the bomb
                this.bombs.splice(bombIndex, 1);

                // Create shrapnel bullets in all directions
                for (let i = 0; i < shrapnelCount; i++) {
                    const angle = (i / shrapnelCount) * Math.PI * 2;
                    const shrapnel = new Bullet(
                        bomb.pos.x,
                        bomb.pos.y,
                        Math.cos(angle) * 400,
                        Math.sin(angle) * 400,
                        Math.min(bomb.weaponLevel || 0, 2),
                        bomb.ownerId || null,
                        false // Shrapnel doesn't bounce
                    );
                    this.playerShip.bullets.push(shrapnel);
                }

                // Damage all players within explosion radius
                this.damagePlayersInRadius(
                    bomb.pos.x,
                    bomb.pos.y,
                    explosionRadius,
                    bomb.damage,
                    bomb.ownerId,
                    bomb.bombType,
                    bomb.isMine
                );

                // Send explosion to multiplayer
                this.sendMultiplayerMessage({
                    type: 'bombExplosion',
                    x: bomb.pos.x,
                    y: bomb.pos.y,
                    bombType: bomb.bombType,
                    ownerId: bomb.ownerId || null,
                    isMine: !!bomb.isMine
                });
            }

            damagePlayersInRadius(x, y, radius, baseDamage, ownerId = null, bombType = null, isMine = false) {
                if (this.safeZone && this.isInSafeZone(x, y)) {
                    return;
                }

                const ownerIsLocalPlayer = ownerId && (ownerId === this.playerId || ownerId === 'local');
                if (ownerIsLocalPlayer && this.safeZone && this.isInSafeZone(this.playerShip.pos.x, this.playerShip.pos.y)) {
                    return;
                }

                // Damage local player
                const localDx = this.playerShip.pos.x - x;
                const localDy = this.playerShip.pos.y - y;
                const localDistance = Math.sqrt(localDx * localDx + localDy * localDy);

                const localOwnerId = this.playerId || 'local';
                const skipLocal = isMine && ownerId && ownerId === localOwnerId;

                if (!skipLocal && localDistance < radius && !this.isInSafeZone(this.playerShip.pos.x, this.playerShip.pos.y)) {
                    const damageMult = 1 - (localDistance / radius); // Closer = more damage
                    const finalDamage = Math.max(1, Math.floor(baseDamage * damageMult));

                    this.applyDamageToPlayerShip(finalDamage, {
                        attackerId: ownerId,
                        weapon: 'bomb',
                        metadata: { bombType }
                    });
                }

                // Damage other multiplayer players
                for (const [playerId, otherPlayer] of this.otherPlayers) {
                    const dx = otherPlayer.pos.x - x;
                    const dy = otherPlayer.pos.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius && !this.isInSafeZone(otherPlayer.pos.x, otherPlayer.pos.y)) {
                        if (isMine && ownerId && ownerId === playerId) {
                            continue;
                        }
                        const damageMult = 1 - (distance / radius);
                        const finalDamage = Math.max(1, Math.floor(baseDamage * damageMult));

                        this.sendMultiplayerMessage({
                            type: 'bombDamage',
                            targetId: playerId,
                            attackerId: ownerId,
                            damage: finalDamage,
                            bombType,
                            isMine
                        });
                    }
                }
            }

            createRemoteBombExplosion(x, y, bombType) {
                const shrapnelCount = 8;

                // Create shrapnel bullets in all directions
                for (let i = 0; i < shrapnelCount; i++) {
                    const angle = (i / shrapnelCount) * Math.PI * 2;
                    const shrapnel = new Bullet(
                        x,
                        y,
                        Math.cos(angle) * 400,
                        Math.sin(angle) * 400,
                        0,
                        null,
                        false // Remote shrapnel doesn't bounce
                    );
                    this.playerShip.bullets.push(shrapnel);
                }
            }

            drawShipSprite(shipType, x, y, angle) {
                // If the sprite hasn't loaded yet, bail out
                if (!this.shipLoaded || !this.processedShipCanvas) return false;

                // Use the first frame (upright) and rotate with canvas transform
                const baseCol = 0;
                const baseRow = 0;

                // Offset to the correct ship type (each type occupies 4 rows of frames)
                const baseY = (shipType - 1) * 4 * this.shipFrameHeight;

                // Sample the central 32×32 pixels of that frame
                const srcX = baseCol * this.shipFrameWidth + 4;
                const srcY = baseY + baseRow * this.shipFrameHeight + 2;
                const srcW = 32;
                const srcH = 32;

                const dest = this.playerShip.spriteDrawSize;

                this.ctx.save();

                // Move to ship center, then rotate around the ship's centre
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);

                // Draw the upright ship rotated
                this.ctx.drawImage(
                    this.processedShipCanvas,
                    srcX, srcY, srcW, srcH,
                    -dest / 2, -dest / 2,
                    dest, dest
                );

                this.ctx.restore();
                return true; // prevent fallback triangle
            }

            changeShip(direction) {
                // Change the player's ship type (1-8)
                this.playerShip.shipType += direction;
                if (this.playerShip.shipType < 1) this.playerShip.shipType = 8;
                if (this.playerShip.shipType > 8) this.playerShip.shipType = 1;

                this.playerShip.updateStatsFromLevels();
                this.updateHUD();

                // Update the HUD display
                const shipName = this.shipTypes[this.playerShip.shipType]?.name || 'Unknown';
                document.getElementById('shipType').textContent = shipName;

                // Send ship change to multiplayer if connected
                if (this.isMultiplayer && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'shipChange',
                        shipType: this.playerShip.shipType
                    }));
                    this.broadcastPlayerState(true);
                }
            }

            showPowerUpMessage(powerUpConfig) {
                // Create the message element
                const messageEl = document.createElement('div');
                messageEl.className = 'power-up-message';
                messageEl.style.color = powerUpConfig.color;
                messageEl.style.borderColor = powerUpConfig.color;
                messageEl.style.textShadow = `2px 2px 4px #000, 0 0 15px ${powerUpConfig.color}`;
                messageEl.innerHTML = `
                    <div style="font-size: 28px; margin-bottom: 5px;">${powerUpConfig.name}</div>
                    <div style="font-size: 18px;">${powerUpConfig.message}</div>
                `;

                // Add to container
                const container = document.getElementById('messageContainer');
                container.appendChild(messageEl);

                // Play power-up sound (Web Audio API)
                this.playPowerUpSound(powerUpConfig.effect);

                // Remove message after animation
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 3000);
            }

            playPowerUpSound(type) {
                // Create Web Audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Different sound frequencies for different power-ups
                const frequencies = {
                    energy: [440, 880], // A4 to A5
                    speed: [523, 1047], // C5 to C6
                    weapons: [659, 1319], // E5 to E6
                    shield: [392, 784], // G4 to G5
                    recharge: [494, 988], // B4 to B5
                    thrust: [587, 1175], // D5 to D6
                    rotation: [698, 1397], // F5 to F6
                    bouncing: [784, 1568] // G5 to G6
                };

                const freqs = frequencies[type] || frequencies.energy;

                // Create oscillator for power-up sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Configure sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freqs[0], audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freqs[1], audioContext.currentTime + 0.3);

                // Volume envelope
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

                // Play sound
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            spawnInitialPowerUps() {
                const powerUpTypes = ['energy', 'speed', 'weapons', 'shield', 'recharge', 'thrust', 'rotation', 'wall', 'bouncing'];

                // Spawn 6 initial power-ups (100% increase from 3)
                for (let i = 0; i < 6; i++) {
                    const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    const x = Math.random() * (this.viewport.worldWidth - 200) + 100;
                    const y = Math.random() * (this.viewport.worldHeight - 200) + 100;
                    const position = this.findValidPowerUpPosition(x, y);

                    this.powerUps.push(new PowerUp(position.x, position.y, type));
                }
            }

            spawnPowerUp() {
                const powerUpTypes = ['energy', 'speed', 'weapons', 'shield', 'recharge', 'thrust', 'rotation', 'wall', 'bouncing'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                console.log(`Spawning power-up: ${type}`); // Debug log

                // Spawn away from player but within reasonable distance
                const minDistance = 200;
                const maxDistance = 800;
                const angle = Math.random() * Math.PI * 2;
                const distance = minDistance + Math.random() * (maxDistance - minDistance);

                const preferredX = this.playerShip.pos.x + Math.cos(angle) * distance;
                const preferredY = this.playerShip.pos.y + Math.sin(angle) * distance;
                const position = this.findValidPowerUpPosition(preferredX, preferredY);

                this.powerUps.push(new PowerUp(position.x, position.y, type));
            }

            findValidPowerUpPosition(preferredX, preferredY, attempts = 5) {
                let x = preferredX;
                let y = preferredY;
                const margin = 60;

                for (let i = 0; i < attempts; i++) {
                    ({ x, y } = this.clampPositionToWorld(x, y, margin));

                    if (!this.safeZone) {
                        break;
                    }

                    const dx = x - this.safeZone.x;
                    const dy = y - this.safeZone.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = this.safeZone.radius + margin;

                    if (!Number.isFinite(distance) || distance < 1) {
                        const angle = Math.random() * Math.PI * 2;
                        x = this.safeZone.x + Math.cos(angle) * minDistance;
                        y = this.safeZone.y + Math.sin(angle) * minDistance;
                        continue;
                    }

                    if (distance < minDistance) {
                        const scale = minDistance / distance;
                        x = this.safeZone.x + dx * scale;
                        y = this.safeZone.y + dy * scale;
                        continue;
                    }

                    break;
                }

                ({ x, y } = this.clampPositionToWorld(x, y, margin));
                return { x, y };
            }

            clampPositionToWorld(x, y, margin = 50) {
                const viewport = this.viewport || null;
                const width = viewport && Number.isFinite(viewport.worldWidth) ? viewport.worldWidth : WORLD_WIDTH;
                const height = viewport && Number.isFinite(viewport.worldHeight) ? viewport.worldHeight : WORLD_HEIGHT;

                const minX = margin;
                const maxX = width - margin;
                const minY = PLAYFIELD_TOP + margin;
                const maxY = PLAYFIELD_BOTTOM - margin;

                const clampedX = Math.max(minX, Math.min(maxX, x));
                const clampedY = Math.max(minY, Math.min(maxY, y));

                return { x: clampedX, y: clampedY };
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'F7') {
                        this.attemptWarpToSafeZone();
                        e.preventDefault();
                        return;
                    }
                    this.keys[e.code] = true;
                    this.updateInput();
                    e.preventDefault();
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    this.updateInput();
                    e.preventDefault();
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            updateInput() {
                this.input.left = this.keys['KeyA'] || this.keys['ArrowLeft'];
                this.input.right = this.keys['KeyD'] || this.keys['ArrowRight'];
                this.input.thrust = this.keys['KeyW'] || this.keys['ArrowUp'];
                this.input.reverse = this.keys['KeyS'] || this.keys['ArrowDown'];
                this.input.brake = this.keys['Space'];
                const shiftHeld = this.keys['ShiftLeft'] || this.keys['ShiftRight'];
                this.input.boost = shiftHeld;
                this.input.fire = this.keys['ControlLeft'] || this.keys['ControlRight'];
                const tabHeld = this.keys['Tab'];
                this.input.deployMine = shiftHeld && tabHeld;
                this.input.bomb = tabHeld && !shiftHeld;
                this.input.deployWall = this.keys['F2'];
                this.input.burst = this.keys['F3'];

                // Handle F12 for config panel
                if (this.keys['F12']) {
                    this.toggleConfigPanel();
                    this.keys['F12'] = false; // Prevent repeated toggles
                }
            }

            attemptWarpToSafeZone() {
                const ship = this.playerShip;
                if (!ship || !this.safeZone) {
                    return;
                }

                const maxEnergy = Number(ship.maxEnergy);
                const energy = Number(ship.energy);
                if (!Number.isFinite(maxEnergy) || !Number.isFinite(energy)) {
                    return;
                }

                const tolerance = Math.max(1, maxEnergy * 0.001);
                if (energy + tolerance < maxEnergy) {
                    return;
                }

                this.performLocalWarp(this.playerId || 'local');
                this.updateHUD();

                if (this.isMultiplayer) {
                    this.sendMultiplayerMessage({
                        type: 'warpToSafe',
                        energy,
                        maxEnergy
                    });
                }
            }

            performLocalWarp(playerId) {
                const ship = playerId === this.playerId ? this.playerShip : this.otherPlayers.get(playerId);
                if (!ship || !this.safeZone) {
                    return;
                }

                ship.pos.x = this.safeZone.x;
                ship.pos.y = this.safeZone.y;
                if (ship.vel) {
                    ship.vel.x = 0;
                    ship.vel.y = 0;
                }
                if (ship.boostActive !== undefined) {
                    ship.boostActive = false;
                }
                if (ship.repelBoostTimer !== undefined) {
                    ship.repelBoostTimer = 0;
                    ship.repelSpeedMultiplierActive = 1;
                }

                if (playerId === this.playerId) {
                    this.clearLocalOrdnance();
                    this.lastBroadcastState.time = 0;
                    this.lastBroadcastState.x = ship.pos.x;
                    this.lastBroadcastState.y = ship.pos.y;
                    this.lastBroadcastState.rotation = ship.angle;
                    this.broadcastPlayerState(true);
                } else {
                    this.clearOrdnanceForPlayer(playerId);
                }
            }

            clearLocalOrdnance() {
                const ownerId = this.playerId || 'local';
                this.clearOrdnanceForPlayer(ownerId);
            }

            clearOrdnanceForPlayer(playerId) {
                if (!playerId) {
                    return;
                }
                this.bombs = this.bombs.filter(bomb => !(bomb && bomb.ownerId === playerId));
                const pruneBullets = (ship) => {
                    if (!ship || !Array.isArray(ship.bullets)) {
                        return;
                    }
                    ship.bullets = ship.bullets.filter(bullet => !(bullet && bullet.ownerId === playerId));
                };
                pruneBullets(this.playerShip);
                for (const ship of this.otherPlayers.values()) {
                    pruneBullets(ship);
                }
            }

            updateHUD() {
                const ship = this.playerShip;

                // Basic stats
                document.getElementById('energy').textContent = Math.floor(ship.energy);
                document.getElementById('maxEnergy').textContent = ship.maxEnergy;
                const boostStatusEl = document.getElementById('boostStatus');
                if (boostStatusEl) {
                    if (ship.boostActive) {
                        boostStatusEl.textContent = 'Boosting';
                    } else if (ship.energy <= ship.boostMinEnergy) {
                        boostStatusEl.textContent = 'Low Energy';
                    } else {
                        boostStatusEl.textContent = 'Ready';
                    }
                }
                const shieldStatusEl = document.getElementById('shieldStatus');
                if (shieldStatusEl) {
                    if (ship.isShieldActive()) {
                        const remaining = ship.shieldTimer > 0 ? ship.shieldTimer : 0;
                        shieldStatusEl.textContent = `Active (${remaining.toFixed(1)}s)`;
                    } else {
                        shieldStatusEl.textContent = 'Inactive';
                    }
                }
                document.getElementById('powerUps').textContent = this.powerUpsCollected;
                document.getElementById('wallCount').textContent = formatLevelDisplay(ship.wallCount, UPGRADE_LIMITS.wallCount);
                document.getElementById('deaths').textContent = ship.deaths;

                // Upgrade levels and their effects
                const shipName = this.shipTypes[ship.shipType]?.name || 'Unknown';
                document.getElementById('shipType').textContent = shipName;
                document.getElementById('energyLevel').textContent = formatLevelDisplay(ship.energyLevel, UPGRADE_LIMITS.energyLevel);
                document.getElementById('speedLevel').textContent = formatLevelDisplay(ship.maxSpeedLevel, UPGRADE_LIMITS.maxSpeedLevel);
                document.getElementById('maxSpeed').textContent = Math.floor(ship.maxSpeed);
                document.getElementById('bulletType').textContent = ship.bulletType.charAt(0).toUpperCase() + ship.bulletType.slice(1);

                // Show bullet bouncing status
                const bounceText = ship.bulletBounce ? '(Bouncing)' : '(No Bounce)';
                document.getElementById('bulletBounce').textContent = bounceText;

                // Show bullet damage for 3-level system
                const currentDamage = this.getBulletDamage(Math.min(Math.max(ship.weaponLevel, 0), 2));
                document.getElementById('bulletDamage').textContent = currentDamage;
                document.getElementById('bombType').textContent = ship.bulletType.charAt(0).toUpperCase() + ship.bulletType.slice(1);
                document.getElementById('rechargeLevel').textContent = formatLevelDisplay(ship.rechargeLevel, UPGRADE_LIMITS.rechargeLevel);
                const rechargeMultiplier = ship.baseEnergyRecharge > 0 ? (ship.energyRecharge / ship.baseEnergyRecharge) : 1;
                const rechargeBonus = (rechargeMultiplier - 1) * 100;
                document.getElementById('rechargeRate').textContent = formatPercentDisplay(rechargeBonus, ship.rechargeLevel >= UPGRADE_LIMITS.rechargeLevel);
                document.getElementById('thrustLevel').textContent = formatLevelDisplay(ship.thrustLevel, UPGRADE_LIMITS.thrustLevel);
                const thrustBonus = ship.thrustLevel * 2;
                document.getElementById('thrustBonus').textContent = formatPercentDisplay(thrustBonus, ship.thrustLevel >= UPGRADE_LIMITS.thrustLevel);
                document.getElementById('rotationLevel').textContent = formatLevelDisplay(ship.rotationLevel, UPGRADE_LIMITS.rotationLevel);
                const rotationBonus = ship.rotationLevel * 33;
                const rotationText = formatPercentDisplay(rotationBonus, ship.rotationLevel >= UPGRADE_LIMITS.rotationLevel);
                document.getElementById('rotationBonus').textContent = rotationText;

                // Energy bar
                const energyFill = document.getElementById('energyFill');
                energyFill.style.width = (ship.energy / ship.maxEnergy * 100) + '%';
            }

            generateEntityId(prefix = 'ent') {
                const counter = this.entityIdCounter = (this.entityIdCounter || 0) + 1;
                return `${prefix}_${Date.now().toString(36)}_${counter.toString(36)}`;
            }

            countActiveMines(ownerId = null) {
                const targetId = ownerId || this.playerId || 'local';
                return this.bombs.reduce((acc, bomb) => {
                    if (!bomb || !bomb.isMine || bomb.exploded) {
                        return acc;
                    }
                    return bomb.ownerId === targetId ? acc + 1 : acc;
                }, 0);
            }

            draw() {
                // Debug: Log drawing info (commented out to reduce spam)
                // console.log(`Drawing: canvas ${this.canvas.width}x${this.canvas.height}, player at (${this.playerShip.pos.x}, ${this.playerShip.pos.y})`);

                // Update viewport to follow player
                this.viewport.follow(this.playerShip);

                // Clear canvas with proper space background gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#001122');
                gradient.addColorStop(0.5, '#002244');
                gradient.addColorStop(1, '#001122');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw safe zone overlay before entities
                // Draw scrolling stars
                this.drawStars();

                this.drawSafeZone();

                // Draw all ships that are visible
                for (const ship of this.ships) {
                    if (this.viewport.isVisible(ship)) {
                        ship.draw(this.ctx, this.viewport);
                    }
                }

                // Draw other multiplayer players
                if (this.isMultiplayer) {
                    for (const [playerId, player] of this.otherPlayers) {
                        if (this.viewport.isVisible(player)) {
                            player.draw(this.ctx, this.viewport);
                        }
                    }
                }

                // Draw power-ups
                for (const powerUp of this.powerUps) {
                    if (this.viewport.isVisible(powerUp)) {
                        powerUp.draw(this.ctx, this.viewport);
                    }
                }

                // Draw bombs
                for (const bomb of this.bombs) {
                    bomb.draw(this.ctx, this.viewport);
                }

                // Draw walls
                for (const wall of this.walls) {
                    wall.draw(this.ctx, this.viewport);
                }

                // Draw burst effects
                if (this.burstEffects) {
                    for (const burst of this.burstEffects) {
                        const screenPos = this.viewport.worldToScreen(burst.x, burst.y);
                        const alpha = burst.lifetime / burst.maxLifetime;

                        this.ctx.globalAlpha = alpha * 0.5;
                        this.ctx.strokeStyle = '#00FFFF';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x, screenPos.y, burst.radius * this.viewport.zoom, 0, Math.PI * 2);
                        this.ctx.stroke();

                        this.ctx.globalAlpha = alpha * 0.2;
                        this.ctx.fillStyle = '#00FFFF';
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;
                    }
                }

                // Only draw world boundaries if we're near them
                this.drawWorldBounds();
            }

            isInSafeZone(x, y) {
                if (!this.safeZone) {
                    return false;
                }
                const dx = x - this.safeZone.x;
                const dy = y - this.safeZone.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.safeZone.radius;
            }

            drawSafeZone() {
                if (!this.safeZone) {
                    return;
                }

                const screenPos = this.viewport.worldToScreen(this.safeZone.x, this.safeZone.y);
                const radius = this.safeZone.radius * this.viewport.zoom;

                this.ctx.save();
                this.ctx.beginPath();
                const gradient = this.ctx.createRadialGradient(
                    screenPos.x,
                    screenPos.y,
                    radius * 0.1,
                    screenPos.x,
                    screenPos.y,
                    radius
                );
                gradient.addColorStop(0, 'rgba(0, 255, 200, 0.35)');
                gradient.addColorStop(1, 'rgba(0, 255, 200, 0)');
                this.ctx.fillStyle = gradient;
                this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = 'rgba(0, 255, 200, 0.6)';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([12, 6]);
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = 'rgba(0, 255, 200, 0.85)';
                this.ctx.font = '18px "Courier New", monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('SAFE ZONE', screenPos.x, screenPos.y);

                this.ctx.restore();
            }

            drawStars() {
                this.ctx.fillStyle = '#ffffff';

                // Calculate visible star region based on viewport
                const margin = 50;
                const startX = Math.max(0, Math.floor((this.viewport.x - this.viewport.width / 2 - margin) / 127));
                const endX = Math.min(Math.floor(this.viewport.worldWidth / 127), Math.ceil((this.viewport.x + this.viewport.width / 2 + margin) / 127));
                const startY = Math.max(0, Math.floor((this.viewport.y - this.viewport.height / 2 - margin) / 191));
                const endY = Math.min(Math.floor(this.viewport.worldHeight / 191), Math.ceil((this.viewport.y + this.viewport.height / 2 + margin) / 191));

                // Draw stars in visible region only
                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        const worldX = x * 127;
                        const worldY = y * 191;

                        if (worldX < this.viewport.worldWidth && worldY < this.viewport.worldHeight) {
                            const screenPos = this.viewport.worldToScreen(worldX, worldY);

                            // Make sure star is actually on screen
                            if (screenPos.x >= -5 && screenPos.x <= this.canvas.width + 5 &&
                                screenPos.y >= -5 && screenPos.y <= this.canvas.height + 5) {
                                const size = ((x + y) % 3) + 1;
                                this.ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), size, size);
                            }
                        }
                    }
                }
            }

            drawWorldBounds() {
                // Only draw boundaries if we're near the world edge
                const margin = 200;
                const ship = this.playerShip;

                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([20, 10]);

                // Left edge
                if (ship.pos.x < margin) {
                    const screenPos = this.viewport.worldToScreen(0, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                }

                // Right edge
                if (ship.pos.x > this.viewport.worldWidth - margin) {
                    const screenPos = this.viewport.worldToScreen(this.viewport.worldWidth, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                }

                // Top edge
                if (ship.pos.y < PLAYFIELD_TOP + margin) {
                    const screenPos = this.viewport.worldToScreen(0, PLAYFIELD_TOP);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenPos.y);
                    this.ctx.lineTo(this.canvas.width, screenPos.y);
                    this.ctx.stroke();
                }

                // Bottom edge
                if (ship.pos.y > PLAYFIELD_BOTTOM - margin) {
                    const screenPos = this.viewport.worldToScreen(0, PLAYFIELD_BOTTOM);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenPos.y);
                    this.ctx.lineTo(this.canvas.width, screenPos.y);
                    this.ctx.stroke();
                }

                this.ctx.setLineDash([]);
            }

            triggerRepel(x, y, sourceId = null, replicate = false, override = {}) {
                const config = {
                    radius: Number.isFinite(override.radius) ? override.radius : this.repelRadius,
                    force: Number.isFinite(override.force) ? override.force : this.repelForce,
                    shipSpeedMultiplier: Number.isFinite(override.shipSpeedMultiplier) ? override.shipSpeedMultiplier : this.repelShipSpeedMultiplier,
                    bombSpeedCap: Number.isFinite(override.bombSpeedCap) ? override.bombSpeedCap : this.repelBombSpeedCap,
                    bulletSpeedCap: Number.isFinite(override.bulletSpeedCap) ? override.bulletSpeedCap : this.repelBulletSpeedCap,
                    shipBoostDuration: Number.isFinite(override.shipBoostDuration) ? override.shipBoostDuration : this.repelShipBoostDuration
                };

                this.applyRepelForce(x, y, sourceId, config);

                this.burstEffects = this.burstEffects || [];
                this.burstEffects.push({
                    x,
                    y,
                    radius: 0,
                    maxRadius: config.radius,
                    lifetime: 0.9,
                    maxLifetime: 0.9
                });

                if (replicate && this.isMultiplayer) {
                    this.sendMultiplayerMessage({
                        type: 'burst',
                        x,
                        y,
                        radius: config.radius,
                        force: config.force,
                        shipSpeedMultiplier: config.shipSpeedMultiplier,
                        bombSpeedCap: config.bombSpeedCap,
                        bulletSpeedCap: config.bulletSpeedCap,
                        shipBoostDuration: config.shipBoostDuration
                    });
                }
            }

            applyRepelForce(x, y, sourceId = null, config = {}) {
                const radius = Number.isFinite(config.radius) ? config.radius : this.repelRadius;
                const force = Number.isFinite(config.force) ? config.force : this.repelForce;
                const shipMultiplier = Number.isFinite(config.shipSpeedMultiplier) ? config.shipSpeedMultiplier : this.repelShipSpeedMultiplier;
                const bombCap = Number.isFinite(config.bombSpeedCap) ? config.bombSpeedCap : this.repelBombSpeedCap;
                const bulletCap = Number.isFinite(config.bulletSpeedCap) ? config.bulletSpeedCap : this.repelBulletSpeedCap;
                const boostDuration = Number.isFinite(config.shipBoostDuration) ? config.shipBoostDuration : this.repelShipBoostDuration;

                if (!Number.isFinite(radius) || radius <= 0 || !Number.isFinite(force)) {
                    return;
                }

                const radiusSq = radius * radius;
                const effectiveSourceId = sourceId || (this.playerId || 'local');

                const applyImpulse = (pos, vel, options = {}) => {
                    if (!pos || !vel) {
                        return null;
                    }
                    const dx = pos.x - x;
                    const dy = pos.y - y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= 0 || distSq > radiusSq) {
                        return null;
                    }
                    const distance = Math.sqrt(distSq);
                    if (distance <= 0) {
                        return null;
                    }
                    const falloff = 1 - (distance / radius);
                    if (falloff <= 0) {
                        return null;
                    }

                    const nx = dx / distance;
                    const ny = dy / distance;
                    const impulse = force * 0.45 * Math.max(options.minStrength ?? 0.2, falloff);

                    vel.x += nx * impulse;
                    vel.y += ny * impulse;

                    const displacement = (options.displacementFactor ?? 0.1) * radius * falloff;
                    if (displacement > 0) {
                        pos.x += nx * displacement;
                        pos.y += ny * displacement;
                    }

                    const maxSpeed = Number.isFinite(options.maxSpeed) ? options.maxSpeed : null;
                    if (maxSpeed) {
                        const speedSq = vel.x * vel.x + vel.y * vel.y;
                        const maxSpeedSq = maxSpeed * maxSpeed;
                        if (speedSq > maxSpeedSq) {
                            const scale = Math.sqrt(maxSpeedSq / speedSq);
                            vel.x *= scale;
                            vel.y *= scale;
                        }
                    }

                    return {
                        impulse,
                        falloff,
                        nx,
                        ny
                    };
                };

                const processShip = (ship, ownerId) => {
                    if (!ship || !ship.pos || !ship.vel) {
                        return;
                    }
                    if (ownerId && effectiveSourceId && ownerId === effectiveSourceId) {
                        return;
                    }
                    if (this.safeZone && this.isInSafeZone(ship.pos.x, ship.pos.y)) {
                        return;
                    }
                    const baseSpeed = Number.isFinite(ship.maxSpeed) ? ship.maxSpeed : null;
                    const cap = baseSpeed ? baseSpeed * shipMultiplier : null;
                const result = applyImpulse(ship.pos, ship.vel, {
                    maxSpeed: cap,
                    displacementFactor: 0.12,
                    minStrength: 0.3
                });
                    if (result && baseSpeed) {
                        const targetMultiplier = Math.max(shipMultiplier, 1 + result.falloff * (shipMultiplier * 0.6));
                        ship.repelBoostTimer = Math.max(ship.repelBoostTimer || 0, boostDuration);
                        ship.repelSpeedMultiplierActive = Math.max(ship.repelSpeedMultiplierActive || 1, targetMultiplier);
                    }
                };

                processShip(this.playerShip, this.playerId || 'local');
                for (const [playerId, ship] of this.otherPlayers.entries()) {
                    processShip(ship, playerId);
                }

                const processBomb = (bomb) => {
                    if (!bomb || !bomb.pos || !bomb.vel) {
                        return;
                    }
                    if (this.safeZone && this.isInSafeZone(bomb.pos.x, bomb.pos.y)) {
                        return;
                    }
                    if (effectiveSourceId && bomb.ownerId === effectiveSourceId && !bomb.isMine) {
                        return;
                    }
                    if (bomb.isMine && effectiveSourceId && bomb.ownerId === effectiveSourceId && !bomb.isDislodged) {
                        return;
                    }
                    const result = applyImpulse(bomb.pos, bomb.vel, {
                        maxSpeed: bombCap,
                    displacementFactor: 0.1,
                    minStrength: 0.25
                });
                if (result) {
                        if (bomb.isMine) {
                            bomb.isMine = false;
                            bomb.isDislodged = true;
                            bomb.armDelay = Math.max(0.15, bomb.armDelay || 0.15);
                            bomb.repelGrace = Math.max(bomb.repelGrace || 0, 0.6);
                            if (this.isMultiplayer && bomb.id) {
                                this.sendMultiplayerMessage({
                                    type: 'mineDislodged',
                                    bombId: bomb.id
                                });
                            }
                        } else {
                            bomb.repelGrace = Math.max(bomb.repelGrace || 0, 0.4);
                        }
                }
            };

                for (const bomb of this.bombs) {
                    processBomb(bomb);
                }

                const processBullets = (ship) => {
                    if (!ship || !Array.isArray(ship.bullets)) {
                        return;
                    }
                    for (const bullet of ship.bullets) {
                        if (!bullet || !bullet.pos || !bullet.vel || bullet.visualOnly) {
                            continue;
                        }
                        if (effectiveSourceId && bullet.ownerId && bullet.ownerId === effectiveSourceId) {
                            continue;
                        }
                        const result = applyImpulse(bullet.pos, bullet.vel, {
                            maxSpeed: bulletCap,
                            displacementFactor: 0.08,
                            minStrength: 0.2
                        });
                    }
                };

                processBullets(this.playerShip);
                for (const ship of this.otherPlayers.values()) {
                    processBullets(ship);
                }
            }

            setupConfigPanel() {
                // Setup sliders for upgrade levels
                const sliders = {
                    energyLevel: { slider: 'energyLevelSlider', value: 'energyLevelValue', property: 'energyLevel' },
                    speedLevel: { slider: 'speedLevelSlider', value: 'speedLevelValue', property: 'maxSpeedLevel' },
                    weaponLevel: { slider: 'weaponLevelSlider', value: 'weaponLevelValue', property: 'weaponLevel' },
                    rechargeLevel: { slider: 'rechargeLevelSlider', value: 'rechargeLevelValue', property: 'rechargeLevel' },
                    thrustLevel: { slider: 'thrustLevelSlider', value: 'thrustLevelValue', property: 'thrustLevel' },
                    rotationLevel: { slider: 'rotationLevelSlider', value: 'rotationLevelValue', property: 'rotationLevel' },
                    wallCount: { slider: 'wallCountSlider', value: 'wallCountValue', property: 'wallCount' }
                };

                this.upgradeSliders = sliders;

                Object.entries(sliders).forEach(([key, config]) => {
                    const slider = document.getElementById(config.slider);
                    const valueDisplay = document.getElementById(config.value);

                    if (slider && valueDisplay) {
                        const limit = UPGRADE_LIMITS[config.property];
                        if (limit !== undefined) {
                            slider.max = limit;
                        }

                        const maxAllowed = limit !== undefined ? limit : Number.MAX_SAFE_INTEGER;
                        const initialValue = clampValue(this.playerShip[config.property] || 0, 0, maxAllowed);
                        slider.value = initialValue;
                        valueDisplay.textContent = limit !== undefined
                            ? formatLevelDisplay(initialValue, limit)
                            : initialValue;

                        slider.addEventListener('input', (e) => {
                            const rawValue = Number(e.target.value);
                            const clampedValue = clampValue(rawValue, 0, maxAllowed);
                            slider.value = clampedValue;
                            valueDisplay.textContent = limit !== undefined
                                ? formatLevelDisplay(clampedValue, limit)
                                : clampedValue;

                            this.playerShip[config.property] = clampedValue;
                            this.playerShip.updateStatsFromLevels();
                            this.updateHUD();
                        });
                    }
                });

                const countInput = document.getElementById('spawnPowerUpCount');
                const countValue = document.getElementById('spawnPowerUpCountValue');
                if (countInput && countValue) {
                    countInput.addEventListener('input', (e) => {
                        const value = clampValue(Number(e.target.value), 1, 250);
                        countInput.value = value;
                        countValue.textContent = value;
                    });
                }

                const spawnBtn = document.getElementById('spawnPowerUpsBtn');
                if (spawnBtn) {
                    spawnBtn.addEventListener('click', () => {
                        const checkedBoxes = Array.from(document.querySelectorAll('.powerup-checkbox:checked'));
                        if (!checkedBoxes.length) {
                            console.warn('No power-up types selected');
                            return;
                        }
                        const count = countInput ? clampValue(Number(countInput.value), 1, 250) : 1;
                        const types = checkedBoxes.map(box => box.value);
                        this.spawnDebugPowerUps(types, count);
                    });
                }

                const clearBtn = document.getElementById('clearPowerUpsBtn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        this.clearNearbyPowerUps();
                    });
                }

                // Bullet bounce checkbox handler
                const bulletBounceCheckbox = document.getElementById('bulletBounceCheckbox');
                if (bulletBounceCheckbox) {
                    bulletBounceCheckbox.checked = this.playerShip.bulletBounce;
                    bulletBounceCheckbox.addEventListener('change', (e) => {
                        this.playerShip.bulletBounce = e.target.checked;
                        this.updateHUD();
                    });
                }

                // Special handler for fire rate (modifies ship config, not ship property)
                const fireRateSlider = document.getElementById('fireRateSlider');
                const fireRateValue = document.getElementById('fireRateValue');
                if (fireRateSlider && fireRateValue) {
                    fireRateSlider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        fireRateValue.textContent = value.toFixed(1);

                        // Update ship config gunTimeoutMultiplier
                        window.shipConfig.updateConfig(1, 'gunTimeoutMultiplier', value);

                        // Force recalculation of gun timeout
                        const config = window.shipConfig.getConfig(this.playerShip.shipType);
                        this.playerShip.gunTimeoutDefault = 0.5 * (config.gunTimeoutMultiplier || 1.0);
                    });
                }
            }

            toggleConfigPanel() {
                const panel = document.getElementById('configPanel');
                if (panel) {
                    const isHidden = panel.style.display === 'none';
                    panel.style.display = isHidden ? 'block' : 'none';

                    // Refresh slider values when opening the panel
                    if (isHidden) {
                        this.refreshConfigPanel();
                    }
                }
            }

            refreshConfigPanel() {
                // Update all sliders to reflect current ship upgrade levels
                Object.values(this.upgradeSliders || {}).forEach((config) => {
                    const slider = document.getElementById(config.slider);
                    const valueDisplay = document.getElementById(config.value);
                    if (!slider || !valueDisplay) {
                        return;
                    }
                    const limit = UPGRADE_LIMITS[config.property];
                    const maxAllowed = limit !== undefined ? limit : Number.MAX_SAFE_INTEGER;
                    const currentValue = clampValue(this.playerShip[config.property] || 0, 0, maxAllowed);
                    slider.value = currentValue;
                    valueDisplay.textContent = limit !== undefined
                        ? formatLevelDisplay(currentValue, limit)
                        : currentValue;
                });

                // Update fire rate slider
                const fireRateSlider = document.getElementById('fireRateSlider');
                const fireRateValue = document.getElementById('fireRateValue');
                const config = window.shipConfig.getConfig(this.playerShip.shipType);
                if (fireRateSlider && fireRateValue && config) {
                    const currentRate = config.gunTimeoutMultiplier || 1.0;
                    fireRateSlider.value = currentRate;
                    fireRateValue.textContent = currentRate.toFixed(1);
                }
            }

            spawnDebugPowerUps(types, count = 1) {
                if (!Array.isArray(types) || !types.length) {
                    return;
                }
                const clampedCount = clampValue(count, 1, 250);
                const angleStep = (Math.PI * 2) / Math.max(clampedCount, 1);
                const radius = 40;

                for (let i = 0; i < clampedCount; i++) {
                    const type = types[i % types.length];
                    const angle = angleStep * i;
                    const offsetX = Math.cos(angle) * radius;
                    const offsetY = Math.sin(angle) * radius;
                    const preferredX = this.playerShip.pos.x + offsetX;
                    const preferredY = this.playerShip.pos.y + offsetY;
                    const position = this.findValidPowerUpPosition(preferredX, preferredY);

                    const powerUp = new PowerUp(position.x, position.y, type);
                    powerUp.debugSpawned = true;
                    this.powerUps.push(powerUp);
                }
            }

            clearNearbyPowerUps(radius = 200) {
                const shipX = this.playerShip.pos.x;
                const shipY = this.playerShip.pos.y;
                const radiusSq = radius * radius;
                this.powerUps = this.powerUps.filter(powerUp => {
                    if (!powerUp || !powerUp.pos) {
                        return false;
                    }
                    const dx = powerUp.pos.x - shipX;
                    const dy = powerUp.pos.y - shipY;
                    const distanceSq = dx * dx + dy * dy;
                    return distanceSq > radiusSq;
                });
            }

            gameLoop(currentTime = 0) {
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;

                // Debug: Log first few frames
                if (currentTime < 5000) {
                    console.log(`Frame ${Math.floor(currentTime)}: playerShip at (${this.playerShip.pos.x}, ${this.playerShip.pos.y})`);
                }

                if (this.running && deltaTime < 0.1) { // Cap deltaTime to prevent large jumps
                    // Update player ship
                    const inSafeZone = this.safeZone && this.isInSafeZone(this.playerShip.pos.x, this.playerShip.pos.y);
                    const brakeFactor = inSafeZone ? 0.5 : 0.95;
                    this.playerShip.processInput(this.input, deltaTime, { brakeFactor });

                    // Share player state when it changes or at steady intervals
                    if (this.isMultiplayer) {
                        const isInputActive = this.input.left || this.input.right || this.input.thrust || this.input.reverse;
                        this.broadcastPlayerState(isInputActive);
                    }

                    // Update all ships
                    for (const ship of this.ships) {
                        ship.update(deltaTime);
                    }

                    // Update other players
                    if (this.isMultiplayer) {
                        for (const [playerId, player] of this.otherPlayers) {
                            player.update(deltaTime);
                        }
                    }

                    // Update power-ups
                    for (const powerUp of this.powerUps) {
                        powerUp.update(deltaTime);

                        // Check collision with player
                        if (powerUp.checkCollision(this.playerShip)) {
                            powerUp.applyEffect(this.playerShip);
                            this.powerUpsCollected++; // Increment bounty counter
                            this.updateLocalBounty();
                            this.showPowerUpMessage(powerUp.config); // Show announcement
                        }
                    }

                    // Remove collected power-ups
                    this.powerUps = this.powerUps.filter(p => !p.collected);

                    // Update bombs
                    for (const bomb of this.bombs) {
                        bomb.update(deltaTime);
                    }

                    // Remove expired bombs
                    this.bombs = this.bombs.filter(bomb => !bomb.expired());

                    // Update walls
                    for (const wall of this.walls) {
                        wall.update(deltaTime);
                    }

                    // Remove expired walls
                    this.walls = this.walls.filter(wall => !wall.expired());

                    // Check bullet-wall collisions
                    for (const ship of this.ships) {
                        for (let i = ship.bullets.length - 1; i >= 0; i--) {
                            const bullet = ship.bullets[i];
                            for (const wall of this.walls) {
                                if (wall.checkBulletCollision(bullet)) {
                                    ship.bullets.splice(i, 1);
                                    break; // Bullet destroyed, check next bullet
                                }
                            }
                        }
                    }

                    // Check bullet-player collisions
                    for (const ship of this.ships) {
                        for (let i = ship.bullets.length - 1; i >= 0; i--) {
                            const bullet = ship.bullets[i];

                            // Check collision with local player
                            if (this.checkBulletPlayerCollision(bullet, this.playerShip)) {
                                const attackerId = bullet.ownerId || null;
                                this.damagePlayer(
                                    bullet.weaponLevel || bullet.upgradeLevel || 0,
                                    attackerId
                                );
                                ship.bullets.splice(i, 1);
                                continue;
                            }

                            // Check collision with other multiplayer players
                            for (const [playerId, otherPlayer] of this.otherPlayers) {
                                if (this.checkBulletPlayerCollision(bullet, otherPlayer)) {
                                    this.handleBulletSelfDamage(bullet, otherPlayer);
                                    // Send damage to other player via server
                                    this.sendPlayerDamage(playerId, bullet);
                                    ship.bullets.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }

                    // Check bomb-wall collisions (bombs bounce)
                    for (const bomb of this.bombs) {
                        for (const wall of this.walls) {
                            wall.checkBombCollision(bomb); // Bomb bounces, wall might be damaged
                        }
                    }

                    // Check bomb proximity to players
                    for (let i = this.bombs.length - 1; i >= 0; i--) {
                        const bomb = this.bombs[i];
                        const proximityRadius = 60; // Bombs explode within 60 pixels

                        // Check proximity to local player
                        if (this.checkBombPlayerProximity(bomb, this.playerShip, proximityRadius, this.playerId || 'local')) {
                            this.explodeBomb(bomb, i);
                            continue;
                        }

                        // Check proximity to other multiplayer players
                        for (const [playerId, otherPlayer] of this.otherPlayers) {
                            if (this.checkBombPlayerProximity(bomb, otherPlayer, proximityRadius, playerId)) {
                                this.explodeBomb(bomb, i);
                                break;
                            }
                        }
                    }

                    // Check ship-wall collisions (ships are blocked)
                    for (const ship of this.ships) {
                        for (const wall of this.walls) {
                            wall.checkShipCollision(ship); // Ship blocked by wall
                        }
                    }

                    // Update burst effects
                    if (this.burstEffects) {
                        for (const burst of this.burstEffects) {
                            burst.lifetime -= deltaTime;
                            burst.radius = burst.maxRadius * (1 - burst.lifetime / burst.maxLifetime);
                        }
                        this.burstEffects = this.burstEffects.filter(burst => burst.lifetime > 0);
                    }

                    // Spawn new power-ups
                    this.powerUpSpawnTimer += deltaTime;
                    if (this.powerUpSpawnTimer >= this.powerUpSpawnInterval) {
                        this.spawnPowerUp();
                        this.powerUpSpawnTimer = 0;
                    }

                    // Update bounty timer
                    this.bountyTimer += deltaTime;
                    if (this.bountyTimer >= this.bountyInterval) {
                        this.powerUpsCollected += this.bountyIncrease;
                        this.updateLocalBounty();
                        this.bountyTimer = 0;

                        // Show bounty increase message
                        const messageEl = document.createElement('div');
                        messageEl.className = 'power-up-message';
                        messageEl.style.color = '#FFD700';
                        messageEl.style.borderColor = '#FFD700';
                        messageEl.style.textShadow = '2px 2px 4px #000, 0 0 15px #FFD700';
                        messageEl.innerHTML = `
                            <div style="font-size: 28px; margin-bottom: 5px;">BOUNTY BONUS!</div>
                            <div style="font-size: 18px;">+${this.bountyIncrease} Bounty</div>
                        `;

                        const container = document.getElementById('messageContainer');
                        container.appendChild(messageEl);

                        setTimeout(() => {
                            if (messageEl.parentNode) {
                                messageEl.parentNode.removeChild(messageEl);
                            }
                        }, 3000);
                    }

                    this.updateHUD();
                    this.draw();

                    // Update minimap
                    if (this.minimap) {
                        this.minimap.update(this);
                    }
                }

                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // Start the game
        window.addEventListener('load', () => {
            window.game = new SubspaceGame();
        });
    </script>
</body>
</html>
