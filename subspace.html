<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subspace Combat</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #333;
            background: linear-gradient(45deg, #001122 0%, #002244 50%, #001122 100%);
            /* Remove CSS scaling to prevent resampling blur */
        }

        .hud {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            color: #00ffff;
            font-size: 12px;
            font-weight: bold;
            line-height: 1.4;
            text-shadow: 1px 1px 2px #000, 0 0 6px #00ffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #00ffff;
            min-width: 180px;
        }

        .energy-bar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.5);
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            transition: width 0.1s ease;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #888;
            line-height: 1.3;
        }

        .power-up-message {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000, 0 0 15px #ffff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #ffff00;
            animation: powerUpAnnounce 3s ease-out forwards;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }

        @keyframes powerUpAnnounce {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1.1);
            }
            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(0px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) scale(1);
            }
        }

        .radar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #0ff;
            border-radius: 50%;
            background: rgba(0, 50, 50, 0.3);
        }

        .config-panel {
            position: fixed;
            top: 10px;
            right: 170px;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            border-radius: 6px;
            padding: 15px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            width: 280px;
            display: none;
        }

        .config-panel h3 {
            margin: 0 0 10px 0;
            color: #ffff00;
            text-align: center;
        }

        .config-slider {
            margin: 8px 0;
        }

        .config-slider label {
            display: block;
            margin-bottom: 3px;
        }

        .config-slider input {
            width: 100%;
            background: #001122;
            border: 1px solid #0ff;
        }

        .config-slider .value {
            color: #ffff00;
            float: right;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1600" height="1000"></canvas>

        <div class="hud">
            <div>Energy: <span id="energy">1100</span> / <span id="maxEnergy">1100</span></div>
            <div>Shield: <span id="shield">0</span> / <span id="maxShield">0</span></div>
            <div>Bounty: <span id="powerUps">0</span></div>
            <div>Walls: <span id="wallCount">0</span></div>
            <div>Deaths: <span id="deaths">0</span></div>
            <div style="margin-top: 10px; border-top: 1px solid #0ff; padding-top: 5px;">
                <div style="font-size: 10px; color: #aaa;">SHIP & UPGRADES:</div>
                <div>Ship: <button onclick="window.game.changeShip(-1)" style="background: #0ff; color: #000; border: none; padding: 2px 6px;">◀</button> <span id="shipType">Warbird</span> <button onclick="window.game.changeShip(1)" style="background: #0ff; color: #000; border: none; padding: 2px 6px;">▶</button></div>
                <div>Energy: Lv.<span id="energyLevel">0</span> (Max: <span id="maxEnergy">1100</span>)</div>
                <div>Speed: Lv.<span id="speedLevel">0</span> (Max: <span id="maxSpeed">500</span>)</div>
                <div>Guns: <span id="bulletType">Red</span> <span id="bulletBounce"></span> (DMG: <span id="bulletDamage">30</span>)</div>
                <div>Bombs: <span id="bombType">Red</span></div>
                <div>Recharge: Lv.<span id="rechargeLevel">0</span> (+<span id="rechargeRate">0</span>%)</div>
                <div>Thrust: Lv.<span id="thrustLevel">0</span> (+<span id="thrustBonus">0</span>%)</div>
                <div>Rotation: Lv.<span id="rotationLevel">0</span> (+<span id="rotationBonus">0</span>%)</div>
                <div>Shield: Lv.<span id="shieldLevel">0</span></div>
            </div>
        </div>

        <div class="energy-bar">
            <div class="energy-fill" id="energyFill"></div>
        </div>

        <div class="controls">
            <div><strong>SUBSPACE CONTROLS:</strong></div>
            <div>A/D - Rotate Left/Right</div>
            <div>W - Thrust</div>
            <div>S - Reverse Thrust</div>
            <div>CTRL - Fire Bullets</div>
            <div>TAB - Fire Bombs</div>
            <div>F2 - Deploy Wall</div>
            <div>F3 - Burst Push</div>
            <div>SPACE - Brake</div>
            <div style="margin-top: 10px; border-top: 1px solid #0ff; padding-top: 5px;">
                <button id="multiplayerBtn" onclick="game.connectToMultiplayer()" style="background: #000; color: #0ff; border: 1px solid #0ff; padding: 5px 10px; font-family: inherit; font-size: 12px; cursor: pointer;">JOIN MULTIPLAYER</button>
                <div id="multiplayerStatus" style="font-size: 10px; color: #888; margin-top: 5px;"></div>
            </div>
        </div>

        <div class="radar" id="radar"></div>

        <!-- Ship Configuration Panel (F12 to toggle) -->
        <div class="config-panel" id="configPanel">
            <h3>⚙️ UPGRADE LEVELS (F12)</h3>

            <div class="config-slider">
                <label>Energy Level <span class="value" id="energyLevelValue">0</span></label>
                <input type="range" id="energyLevelSlider" min="0" max="5" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Speed Level <span class="value" id="speedLevelValue">0</span></label>
                <input type="range" id="speedLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Weapon Level <span class="value" id="weaponLevelValue">0</span></label>
                <input type="range" id="weaponLevelSlider" min="0" max="5" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Recharge Level <span class="value" id="rechargeLevelValue">0</span></label>
                <input type="range" id="rechargeLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Thrust Level <span class="value" id="thrustLevelValue">0</span></label>
                <input type="range" id="thrustLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Rotation Level <span class="value" id="rotationLevelValue">0</span></label>
                <input type="range" id="rotationLevelSlider" min="0" max="3" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Shield Level <span class="value" id="shieldLevelValue">0</span></label>
                <input type="range" id="shieldLevelSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Wall Count <span class="value" id="wallCountValue">0</span></label>
                <input type="range" id="wallCountSlider" min="0" max="10" step="1" value="0">
            </div>

            <div class="config-slider">
                <label>Fire Rate <span class="value" id="fireRateValue">0.7</span></label>
                <input type="range" id="fireRateSlider" min="0.3" max="2.0" step="0.1" value="0.7">
            </div>

            <div style="text-align: center; margin-top: 15px; font-size: 10px; color: #888;">
                <div>Set upgrade levels directly</div>
                <div>F12 to toggle panel</div>
            </div>
        </div>

        <!-- Power-up messages container -->
        <div id="messageContainer"></div>
    </div>

    <script>
        // Ship Configuration System
        class ShipConfig {
            constructor() {
                // Default configuration for all ships - admin adjustable
                this.shipConfigs = {
                    1: { // Warbird
                        name: 'Warbird',
                        baseSpeedMultiplier: 1.0,
                        thrustMultiplier: 1.0,
                        turnRateMultiplier: 1.0,
                        energyCapacityMultiplier: 1.0,
                        bulletDamageMultiplier: 1.0,
                        energyRechargeMultiplier: 1.0,
                        gunTimeoutMultiplier: 0.7 // 30% faster firing (shorter timeout)
                    },
                    // Future ship configs will go here
                    2: { name: 'Javelin', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    3: { name: 'Spider', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    4: { name: 'Leviathan', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    5: { name: 'Terrier', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    6: { name: 'Weasel', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    7: { name: 'Lancaster', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 },
                    8: { name: 'Shark', baseSpeedMultiplier: 1.0, thrustMultiplier: 1.0, turnRateMultiplier: 1.0, energyCapacityMultiplier: 1.0, bulletDamageMultiplier: 1.0, energyRechargeMultiplier: 1.0, gunTimeoutMultiplier: 1.0 }
                };
            }

            getConfig(shipType) {
                return this.shipConfigs[shipType] || this.shipConfigs[1];
            }

            updateConfig(shipType, parameter, value) {
                if (this.shipConfigs[shipType] && this.shipConfigs[shipType].hasOwnProperty(parameter)) {
                    // Validate bounds to prevent breaking the game
                    const clampedValue = Math.max(0.1, Math.min(5.0, value)); // 10% to 500% of normal
                    this.shipConfigs[shipType][parameter] = clampedValue;
                    return true;
                }
                return false;
            }

            // Method for admin console to update configs
            setShipConfig(shipType, configObject) {
                if (this.shipConfigs[shipType]) {
                    Object.assign(this.shipConfigs[shipType], configObject);
                }
            }

            // Get all configs (for admin console)
            getAllConfigs() {
                return JSON.parse(JSON.stringify(this.shipConfigs)); // Deep copy
            }
        }

        // Global ship configuration instance
        window.shipConfig = new ShipConfig();

        // Vector2D class (simplified from valor)
        class Vector2D {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            static fromArray(arr) {
                return new Vector2D(arr[0], arr[1]);
            }

            clone() {
                return new Vector2D(this.x, this.y);
            }

            clear() {
                this.x = this.y = 0;
                return this;
            }

            set(v) {
                this.x = v.x;
                this.y = v.y;
                return this;
            }

            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }

            addXY(x, y) {
                this.x += x;
                this.y += y;
                return this;
            }

            // Key Subspace mechanic: polar addition for thrust
            addPolar(magnitude, angle) {
                this.x += magnitude * Math.sin(angle);
                this.y += magnitude * -Math.cos(angle); // Negative cos for correct orientation
                return this;
            }

            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }

            scale(factor) {
                this.x *= factor;
                this.y *= factor;
                return this;
            }

            clamp(max) {
                const length = this.length();
                if (length > max) {
                    const factor = max / length;
                    this.x *= factor;
                    this.y *= factor;
                }
                return this;
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
        }

        // Ship class (based on valor's Ship.coffee)
        class Ship {
            constructor(x, y, isPlayer = false) {
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(0, 0);
                this.rawAngle = 0;
                this.angle = 0;
                this.isPlayer = isPlayer;

                // Ship properties (from valor)
                this.maxSpeed = 150; // pixels/second, will be recalculated in updateStatsFromLevels()
                // Energy will be set after updateStatsFromLevels() is called
                this.fireEnergy = 20;
                // Base gun timeout (configurable by ship type)
                const baseGunTimeout = 0.5; // seconds
                const config = window.shipConfig ? window.shipConfig.getConfig(this.shipType) : { gunTimeoutMultiplier: 1.0 };
                this.gunTimeoutDefault = baseGunTimeout * (config.gunTimeoutMultiplier || 1.0);
                this.gunTimeout = 0;
                this.burstTimeout = 0;
                this.burstTimeoutDefault = 2.0; // Burst cooldown is 2 seconds
                this.energyRecharge = 50; // Energy recharge rate per second

                this.size = 18; // Reasonable triangle size
                this.bullets = [];

                // Permanent upgrade levels (reset on death)
                this.shield = 0;
                this.maxSpeedLevel = 0; // +50 max speed per level
                this.weaponLevel = 0; // Bullet progression: 0=red, 1=yellow, 2=green
                this.rechargeLevel = 0; // +200% recharge rate per level
                this.thrustLevel = 0; // +2% thrust per level
                this.shieldLevel = 0; // +25 max shield per level
                this.energyLevel = 0; // +200 max energy per level
                this.rotationLevel = 0; // +33% turn rate per level
                this.wallCount = 0; // Number of deployable walls

                // Calculate current stats based on levels
                this.updateStatsFromLevels();

                // Set initial energy to max after stats are calculated
                this.energy = this.maxEnergy;

                // Death tracking
                this.alive = true;
                this.deaths = 0;

                // Physics properties
                this.bounciness = 0.3;
                this.invmass = 1.0;

                // Graphics - use Subspace sprites
                this.shipType = isPlayer ? 1 : Math.floor(Math.random() * 8) + 1; // Ship types 1-8
                this.spriteDrawSize = 48; // Draw 50% larger
                this.spriteSize = 32; // For compatibility
            }

            updateStatsFromLevels() {
                // Get ship-specific configuration
                const config = window.shipConfig.getConfig(this.shipType);

                // Base stats (proper Subspace feel) - now configurable
                const baseMaxSpeed = 150 * config.baseSpeedMultiplier;
                const baseFireEnergy = 20;
                const baseEnergyRecharge = 50 * config.energyRechargeMultiplier;
                const baseThrustMultiplier = 5 * config.thrustMultiplier;
                const baseMaxShield = 0;
                const baseMaxEnergy = 1100 * config.energyCapacityMultiplier;

                // Calculate current stats from upgrade levels
                this.maxSpeed = baseMaxSpeed + (this.maxSpeedLevel * 5 * config.baseSpeedMultiplier);
                this.maxEnergy = baseMaxEnergy + (this.energyLevel * 200 * config.energyCapacityMultiplier);

                // Fire energy costs scale with weapon level (6 levels)
                const baseBulletCost = 67;
                const energyCosts = [67, 75, 90, 100, 120, 140]; // Energy cost per level
                this.fireEnergy = energyCosts[Math.min(this.weaponLevel, 5)] || baseBulletCost;
                this.energyRecharge = baseEnergyRecharge * (1 + this.rechargeLevel * 2.0); // Much higher scaling for infinite green bullets
                this.thrustMultiplier = baseThrustMultiplier * (1 + this.thrustLevel * 0.02); // +2% per level - ORIGINAL VALUE
                this.maxShield = baseMaxShield + (this.shieldLevel * 25);

                // Determine bullet type name for HUD display (6 levels)
                const bulletNames = ['Red', 'Red+', 'Yellow', 'Yellow+', 'Green', 'Green+'];
                this.bulletType = bulletNames[Math.min(this.weaponLevel, 5)] || 'Red';

                // Debug log for bullet level changes
                console.log(`Weapon Level: ${this.weaponLevel}, Bullet Type: ${this.bulletType}`);

                // Cap shield at max level
                if (this.shield > this.maxShield) {
                    this.shield = this.maxShield;
                }
            }

            resetUpgrades() {
                // Called on death - reset all permanent upgrades
                this.maxSpeedLevel = 0;
                this.weaponLevel = 0;
                this.rechargeLevel = 0;
                this.thrustLevel = 0;
                this.shieldLevel = 0;
                this.energyLevel = 0;
                this.rotationLevel = 0;
                this.wallCount = 0;
                this.shield = 0;
                this.updateStatsFromLevels();
            }

            die() {
                // Death effects and respawn
                this.alive = false;
                this.deaths++; // Increment death counter
                this.resetUpgrades();
                this.updateStatsFromLevels(); // Recalculate max energy
                this.energy = this.maxEnergy;
                this.vel.clear();

                // Respawn in center of world
                this.pos.x = 4000;
                this.pos.y = 3000;
                this.angle = 0;
                this.rawAngle = 0;

                // Clear bullets
                this.bullets = [];

                // Mark as alive again
                this.alive = true;
            }

            processInput(input, deltaTime) {
                // Get ship-specific configuration
                const config = window.shipConfig.getConfig(this.shipType);

                // Rotation (much smoother, continuous) - now configurable with upgrades
                // Base speed reduced by 50% so max upgraded speed equals original base speed
                const baseRotationSpeed = 1.5 * config.turnRateMultiplier; // Reduced from 3.0 to 1.5
                const rotationSpeed = baseRotationSpeed * (1 + this.rotationLevel * 0.33); // +33% per level

                if (input.left) {
                    this.angle -= rotationSpeed * deltaTime;
                }
                if (input.right) {
                    this.angle += rotationSpeed * deltaTime;
                }

                // Normalize angle to 0-2π range
                while (this.angle < 0) this.angle += Math.PI * 2;
                while (this.angle >= Math.PI * 2) this.angle -= Math.PI * 2;

                // Keep rawAngle in sync for physics
                this.rawAngle = this.angle;

                // Thrust (reduced base acceleration, can be boosted by power-ups)
                const baseThrustForce = 75; // Increased thrust force by 50% (50 * 1.5 = 75)
                const thrustForce = baseThrustForce * this.thrustMultiplier * deltaTime;
                if (input.thrust) {
                    this.vel.addPolar(thrustForce, this.angle);
                }
                if (input.reverse) {
                    this.vel.addPolar(-thrustForce * 0.5, this.angle);
                }

                // Brake
                if (input.brake) {
                    this.vel.scale(0.95);
                }

                // Firing bullets
                if (input.fire && this.gunTimeout <= 0 && this.energy >= this.fireEnergy) {
                    this.fire();
                }

                // Firing bombs
                if (input.bomb && this.gunTimeout <= 0 && this.energy >= this.getBombEnergy()) {
                    this.fireBomb();
                }

                // Deploy wall
                if (input.deployWall && this.wallCount > 0 && this.gunTimeout <= 0) {
                    this.deployWall();
                }

                // Burst - pushes everything away
                if (input.burst && this.burstTimeout <= 0 && this.energy >= this.getBurstEnergy()) {
                    this.burst();
                }
            }

            fire() {
                this.energy -= this.fireEnergy;
                this.gunTimeout = this.gunTimeoutDefault;

                // Create bullet with ship velocity + bullet velocity
                const bullet = new Bullet(
                    this.pos.x + Math.sin(this.angle) * this.size,
                    this.pos.y + -Math.cos(this.angle) * this.size,
                    this.vel.x + Math.sin(this.angle) * 600, // Bullet speed
                    this.vel.y + -Math.cos(this.angle) * 600,
                    this.weaponLevel // Pass weapon level directly (0-5)
                );

                this.bullets.push(bullet);

                // Send bullet to multiplayer server if connected
                if (window.game && window.game.isMultiplayer) {
                    window.game.sendMultiplayerMessage({
                        type: 'bullet',
                        x: bullet.pos.x,
                        y: bullet.pos.y,
                        vx: bullet.vel.x,
                        vy: bullet.vel.y
                    });
                }
            }

            getBombEnergy() {
                // Red bombs cost 350 energy, Yellow bombs cost 450 energy (allows ~3-5 bombs)
                return this.bulletType === 'yellow' ? 450 : 350;
            }

            fireBomb() {
                const bombEnergy = this.getBombEnergy();
                this.energy -= bombEnergy;
                this.gunTimeout = this.gunTimeoutDefault * 2; // Longer timeout for bombs

                // Create bomb with ship velocity + bomb velocity
                const bomb = new Bomb(
                    this.pos.x + Math.sin(this.angle) * this.size,
                    this.pos.y + -Math.cos(this.angle) * this.size,
                    this.vel.x + Math.sin(this.angle) * 300, // Slower than bullets
                    this.vel.y + -Math.cos(this.angle) * 300,
                    this.bulletType === 'yellow' ? 'yellow' : 'red', // Only red and yellow bombs
                    this.weaponLevel // Pass weapon level for bouncing logic
                );

                // Add to game's bomb array (we'll need to pass this reference)
                if (window.game && window.game.bombs) {
                    window.game.bombs.push(bomb);

                    // Send bomb to multiplayer server if connected
                    if (window.game.isMultiplayer) {
                        window.game.sendMultiplayerMessage({
                            type: 'bomb',
                            x: bomb.pos.x,
                            y: bomb.pos.y,
                            vx: bomb.vel.x,
                            vy: bomb.vel.y,
                            color: bomb.color
                        });
                    }
                }
            }

            deployWall() {
                this.wallCount--;
                this.gunTimeout = this.gunTimeoutDefault; // Small timeout after deploying

                // Create wall behind ship
                if (window.game && window.game.walls) {
                    const wall = new Wall(this.pos.x, this.pos.y, this.angle);
                    window.game.walls.push(wall);

                    // Send wall to multiplayer server if connected
                    if (window.game.isMultiplayer) {
                        window.game.sendMultiplayerMessage({
                            type: 'wall',
                            bricks: wall.bricks.map(brick => ({ x: brick.x, y: brick.y }))
                        });
                    }
                }
            }

            getBurstEnergy() {
                // Burst costs 250 energy
                return 250;
            }

            burst() {
                const burstEnergy = this.getBurstEnergy();
                this.energy -= burstEnergy;
                this.burstTimeout = this.burstTimeoutDefault;

                // Create burst effect
                if (window.game) {
                    window.game.createBurst(this.pos.x, this.pos.y);

                    // Send burst to multiplayer server if connected
                    if (window.game.isMultiplayer) {
                        window.game.sendMultiplayerMessage({
                            type: 'burst',
                            x: this.pos.x,
                            y: this.pos.y
                        });
                    }
                }
            }

            update(deltaTime) {
                // Update timers
                if (this.gunTimeout > 0) {
                    this.gunTimeout -= deltaTime;
                }
                if (this.burstTimeout > 0) {
                    this.burstTimeout -= deltaTime;
                }

                // Energy recharge (based on current upgrade level)
                if (this.energy < this.maxEnergy) {
                    this.energy = Math.min(this.maxEnergy, this.energy + this.energyRecharge * deltaTime);
                }

                // Shield decay (shields don't decay if you have shield upgrades)
                if (this.shield > 0 && this.shieldLevel === 0) {
                    this.shield = Math.max(0, this.shield - 10 * deltaTime);
                }

                // Apply velocity limits
                this.vel.clamp(this.maxSpeed);

                // Update position (apply velocity scaled by deltaTime for proper units)
                this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));

                // Clamp ship to world boundaries (8000 x 6000)
                const margin = this.size; // Ship's collision radius
                this.pos.x = Math.max(margin, Math.min(8000 - margin, this.pos.x));
                this.pos.y = Math.max(margin, Math.min(6000 - margin, this.pos.y));

                // Check for death conditions (only energy-based now, position is clamped)
                if (this.energy <= 0) {
                    this.die();
                    return; // Early exit to prevent further updates
                }


                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.update(deltaTime);

                    if (bullet.expired()) {
                        this.bullets.splice(i, 1);
                    }
                }
            }

            draw(ctx, viewport) {
                // Convert world coordinates to screen coordinates
                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);

                // Set image smoothing for crisp pixel art
                ctx.imageSmoothingEnabled = false;

                ctx.save();

                // Move to ship center
                ctx.translate(screenPos.x, screenPos.y);

                // Don't rotate canvas - the sprite frames are already rotated
                // (Only rotate if we need to draw fallback triangle)
                // Try to draw ship sprite
                let spriteDrawn = false;

                if (window.game && window.game.shipLoaded && window.game.drawShipSprite) {
                    try {
                        spriteDrawn = window.game.drawShipSprite(this.shipType, 0, 0, this.angle);
                    } catch (e) {
                        console.log('Ship sprite drawing failed:', e);
                    }
                }

                // If sprite failed, apply rotation for fallback triangle
                if (!spriteDrawn) {
                    ctx.rotate(this.angle);
                }

                if (!spriteDrawn) {
                    // Fallback triangle
                    ctx.fillStyle = this.isPlayer ? '#00ff00' : '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(-this.size * 0.6, this.size * 0.8);
                    ctx.lineTo(0, this.size * 0.4);
                    ctx.lineTo(this.size * 0.6, this.size * 0.8);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();

                // Restore smoothing for other elements
                ctx.imageSmoothingEnabled = true;

                // Draw bullets
                this.bullets.forEach(bullet => bullet.draw(ctx, viewport));
            }
        }

        // PowerUp class
        class PowerUp {
            constructor(x, y, type) {
                this.pos = new Vector2D(x, y);
                this.type = type;
                this.collected = false;
                this.size = 16;
                this.bounceTime = 0;

                // Power-up types and their effects (permanent until death)
                this.types = {
                    energy: {
                        spriteIndex: 0,
                        color: '#ffff00',
                        effect: 'energy',
                        name: 'ENERGY UPGRADE',
                        message: '+200 Max Energy (Permanent!)'
                    },
                    speed: {
                        spriteIndex: 1,
                        color: '#00ff00',
                        effect: 'speed',
                        name: 'SPEED UPGRADE',
                        message: '+50 Max Speed (Permanent!)'
                    },
                    weapons: {
                        spriteIndex: 2,
                        color: '#ff0000',
                        effect: 'weapons',
                        name: 'WEAPON UPGRADE',
                        message: 'Bullet Upgrade (+100% Energy Cost!)'
                    },
                    shield: {
                        spriteIndex: 3,
                        color: '#0080ff',
                        effect: 'shield',
                        name: 'SHIELD UPGRADE',
                        message: '+25 Max Shield (Permanent!)'
                    },
                    recharge: {
                        spriteIndex: 4,
                        color: '#ff8000',
                        effect: 'recharge',
                        name: 'RECHARGE UPGRADE',
                        message: '+200% Recharge Rate (Permanent!)'
                    },
                    thrust: {
                        spriteIndex: 5,
                        color: '#ff00ff',
                        effect: 'thrust',
                        name: 'THRUST UPGRADE',
                        message: '+2% Acceleration (Permanent!)'
                    },
                    wall: {
                        spriteIndex: 6,
                        color: '#888888',
                        effect: 'wall',
                        name: 'WALL DEPLOYMENT',
                        message: 'Deploys protective wall behind ship!'
                    },
                    rotation: {
                        spriteIndex: 7,
                        color: '#ff8800',
                        effect: 'rotation',
                        name: 'ROTATION UPGRADE',
                        message: '+33% Turn Rate (Permanent!)'
                    }
                };

                this.config = this.types[type] || this.types.energy;

                // Load power-up sprite
                this.powerUpImage = new Image();
                this.powerUpImage.src = 'powerb.png';
                this.spriteSize = 16; // Each power-up is 16x16
            }

            update(deltaTime) {
                this.bounceTime += deltaTime * 4;
            }

            draw(ctx, viewport) {
                if (this.collected) return;

                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                const bounceOffset = Math.sin(this.bounceTime) * 3;

                ctx.save();
                ctx.imageSmoothingEnabled = false;

                if (this.powerUpImage.complete) {
                    // Draw specific power-up frame from sprite sheet
                    const sx = this.config.spriteIndex * this.spriteSize;
                    const sy = 0; // Power-ups are in a single row

                    ctx.drawImage(
                        this.powerUpImage,
                        sx, sy, this.spriteSize, this.spriteSize,
                        screenPos.x - this.size / 2,
                        screenPos.y - this.size / 2 + bounceOffset,
                        this.size, this.size
                    );
                } else {
                    // Fallback colored circle
                    ctx.fillStyle = this.config.color;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y + bounceOffset, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Glow effect
                ctx.globalAlpha = 0.3 + Math.sin(this.bounceTime * 2) * 0.2;
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y + bounceOffset, this.size / 2 + 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            checkCollision(ship) {
                if (this.collected) return false;

                const distance = Math.sqrt(
                    (this.pos.x - ship.pos.x) ** 2 +
                    (this.pos.y - ship.pos.y) ** 2
                );

                return distance < (this.size + ship.size) / 2;
            }

            applyEffect(ship) {
                if (this.collected) return;

                this.collected = true;

                switch (this.config.effect) {
                    case 'energy':
                        // Permanent max energy upgrade
                        if (ship.energyLevel < 5) { // Max level is 5 (reach 2100 total)
                            ship.energyLevel++;
                            ship.updateStatsFromLevels();
                            ship.energy = ship.maxEnergy; // Fill to new max
                        }
                        break;
                    case 'speed':
                        // Permanent speed upgrade
                        ship.maxSpeedLevel++;
                        ship.updateStatsFromLevels();
                        break;
                    case 'weapons':
                        // Permanent weapon upgrade (sequential: red -> yellow -> green)
                        if (ship.weaponLevel < 2) { // Max level is 2 (green bullets)
                            ship.weaponLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                    case 'shield':
                        // Permanent shield upgrade
                        ship.shieldLevel++;
                        ship.updateStatsFromLevels();
                        ship.shield = ship.maxShield; // Fill to new max
                        break;
                    case 'recharge':
                        // Permanent recharge upgrade
                        ship.rechargeLevel++;
                        ship.updateStatsFromLevels();
                        break;
                    case 'thrust':
                        // Permanent thrust upgrade
                        ship.thrustLevel++;
                        ship.updateStatsFromLevels();
                        break;
                    case 'wall':
                        // Add wall to inventory
                        ship.wallCount++;
                        break;
                    case 'rotation':
                        // Permanent rotation upgrade (max level 3 for 100% improvement)
                        if (ship.rotationLevel < 3) {
                            ship.rotationLevel++;
                            ship.updateStatsFromLevels();
                        }
                        break;
                }
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, weaponLevel = 0) {
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(vx, vy);
                this.weaponLevel = weaponLevel;
                this.upgradeLevel = weaponLevel; // Track specific upgrade level (0-5)
                this.bounceCount = 0;
                this.hasHitWall = false;

                // 6-level bullet progression system
                const bulletConfigs = [
                    // Level 0: Basic Red
                    { color: '#ff4444', damage: 30, lifetime: 6.0, canBounce: false, name: 'Red' },
                    // Level 1: Red with Border (bouncing)
                    { color: '#ff4444', damage: 40, lifetime: 7.0, canBounce: true, name: 'Red+' },
                    // Level 2: Basic Yellow
                    { color: '#ffff44', damage: 60, lifetime: 9.0, canBounce: false, name: 'Yellow' },
                    // Level 3: Yellow with Border
                    { color: '#ffff44', damage: 75, lifetime: 11.0, canBounce: false, name: 'Yellow+' },
                    // Level 4: Basic Green
                    { color: '#44ff44', damage: 90, lifetime: 15.0, canBounce: false, name: 'Green' },
                    // Level 5: Green with Border (bouncing)
                    { color: '#44ff44', damage: 120, lifetime: 18.0, canBounce: true, name: 'Green+' }
                ];

                const config = bulletConfigs[Math.min(weaponLevel, 5)] || bulletConfigs[0];
                this.color = config.color;
                this.lifetime = config.lifetime;
                this.maxLifetime = this.lifetime;
                this.canBounce = config.canBounce;
                this.bulletName = config.name;
                this.maxBounces = 1;
                this.size = 4; // Bullet collision size

                // Apply ship-specific damage multiplier
                const shipConfig = window.shipConfig ? window.shipConfig.getConfig(1) : { bulletDamageMultiplier: 1.0 };
                this.damage = config.damage * shipConfig.bulletDamageMultiplier;
            }

            update(deltaTime) {
                this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));
                this.lifetime -= deltaTime;

                // Handle bouncing off world edges
                let shouldBounce = false;
                if (this.pos.x < 0) {
                    this.pos.x = 0;
                    this.vel.x = Math.abs(this.vel.x);
                    shouldBounce = true;
                } else if (this.pos.x > 8000) {
                    this.pos.x = 8000;
                    this.vel.x = -Math.abs(this.vel.x);
                    shouldBounce = true;
                }

                if (this.pos.y < 0) {
                    this.pos.y = 0;
                    this.vel.y = Math.abs(this.vel.y);
                    shouldBounce = true;
                } else if (this.pos.y > 6000) {
                    this.pos.y = 6000;
                    this.vel.y = -Math.abs(this.vel.y);
                    shouldBounce = true;
                }

                if (shouldBounce) {
                    if (this.canBounce && this.bounceCount < this.maxBounces) {
                        this.bounceCount++;
                        // Reduce velocity slightly on bounce
                        this.vel.scale(0.9);
                    } else {
                        this.lifetime = 0; // Destroy bullet if it can't bounce
                    }
                }
            }

            expired() {
                return this.lifetime <= 0;
            }

            draw(ctx, viewport) {
                const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                const alpha = this.lifetime / this.maxLifetime;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Draw bullet based on upgrade level (30% smaller)
                switch(this.upgradeLevel) {
                    case 0: // Level 0: Basic Red Circle
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.1, 0, Math.PI * 2); // 3 * 0.7 = 2.1
                        ctx.fill();
                        break;

                    case 1: // Level 1: Red Circle with White Border (bouncing)
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.1, 0, Math.PI * 2); // 3 * 0.7 = 2.1
                        ctx.fill();
                        // White border to show upgrade
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.8, 0, Math.PI * 2); // 4 * 0.7 = 2.8
                        ctx.stroke();
                        break;

                    case 2: // Level 2: Basic Yellow Circle
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.8, 0, Math.PI * 2); // 4 * 0.7 = 2.8
                        ctx.fill();
                        break;

                    case 3: // Level 3: Yellow Circle with Orange Border
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 2.8, 0, Math.PI * 2); // 4 * 0.7 = 2.8
                        ctx.fill();
                        // Orange border for upgrade
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 1.4; // 2 * 0.7 = 1.4
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 3.5, 0, Math.PI * 2); // 5 * 0.7 = 3.5
                        ctx.stroke();
                        break;

                    case 4: // Level 4: Basic Green Circle
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 3.5, 0, Math.PI * 2); // 5 * 0.7 = 3.5
                        ctx.fill();
                        break;

                    case 5: // Level 5: Green Circle with Cyan Border + Glow (bouncing)
                        // Glow effect
                        ctx.shadowColor = this.color;
                        ctx.shadowBlur = 5.6; // 8 * 0.7 = 5.6
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 3.5, 0, Math.PI * 2); // 5 * 0.7 = 3.5
                        ctx.fill();

                        // Reset shadow
                        ctx.shadowBlur = 0;

                        // Cyan border for max upgrade
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 1.4; // 2 * 0.7 = 1.4
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 4.2, 0, Math.PI * 2); // 6 * 0.7 = 4.2
                        ctx.stroke();
                        break;
                }

                // Add bounce indicator for bouncing bullets (30% smaller)
                if (this.bounceCount > 0) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, 5.6, 0, Math.PI * 2); // 8 * 0.7 = 5.6
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }
        }

        // Bomb class
        class Bomb {
            constructor(x, y, vx, vy, bombType = 'red', weaponLevel = 0) {
                this.pos = new Vector2D(x, y);
                this.vel = new Vector2D(vx, vy);
                this.bombType = bombType;
                this.weaponLevel = weaponLevel;
                this.exploded = false;
                this.shrapnelPieces = [];
                this.bounceCount = 0;
                this.maxBounces = (bombType === 'yellow' && weaponLevel >= 2) ? 1 : 0;
                this.wallBounceCount = 0; // Track wall bounces separately
                this.maxWallBounces = 1; // All bombs can only bounce once off walls

                // Bomb properties based on type
                const bombConfig = {
                    red: {
                        color: '#ff6666',
                        size: 6,
                        shrapnelCount: 8,
                        shrapnelSpeed: 200,
                        explosionRadius: 80,
                        damage: 1
                    },
                    yellow: {
                        color: '#ffff66',
                        size: 8,
                        shrapnelCount: 12,
                        shrapnelSpeed: 250,
                        explosionRadius: 120,
                        damage: 2
                    }
                };

                const config = bombConfig[bombType] || bombConfig.red;
                this.color = config.color;
                this.size = config.size;
                this.shrapnelCount = config.shrapnelCount;
                this.shrapnelSpeed = config.shrapnelSpeed;
                this.explosionRadius = config.explosionRadius;
                this.damage = config.damage;
            }

            update(deltaTime) {
                if (!this.exploded) {
                    this.pos.add(new Vector2D(this.vel.x * deltaTime, this.vel.y * deltaTime));
                    // Bombs don't expire on their own - they travel across the entire map

                    // Check for world edge collisions
                    let shouldBounce = false;
                    if (this.pos.x < 0) {
                        this.pos.x = 0;
                        this.vel.x = Math.abs(this.vel.x);
                        shouldBounce = true;
                    } else if (this.pos.x > 8000) {
                        this.pos.x = 8000;
                        this.vel.x = -Math.abs(this.vel.x);
                        shouldBounce = true;
                    }

                    if (this.pos.y < 0) {
                        this.pos.y = 0;
                        this.vel.y = Math.abs(this.vel.y);
                        shouldBounce = true;
                    } else if (this.pos.y > 6000) {
                        this.pos.y = 6000;
                        this.vel.y = -Math.abs(this.vel.y);
                        shouldBounce = true;
                    }

                    if (shouldBounce) {
                        if (this.bounceCount < this.maxBounces) {
                            this.bounceCount++;
                            // Reduce velocity slightly on bounce
                            this.vel.scale(0.9);
                        } else {
                            this.explode();
                        }
                    }
                } else {
                    // Update shrapnel
                    for (const shrapnel of this.shrapnelPieces) {
                        shrapnel.pos.add(new Vector2D(shrapnel.vel.x * deltaTime, shrapnel.vel.y * deltaTime));
                        shrapnel.lifetime -= deltaTime;
                    }
                    // Remove expired shrapnel
                    this.shrapnelPieces = this.shrapnelPieces.filter(s => s.lifetime > 0);
                }
            }

            explode() {
                if (this.exploded) return;
                this.exploded = true;

                // Create shrapnel pieces
                for (let i = 0; i < this.shrapnelCount; i++) {
                    const angle = (i / this.shrapnelCount) * Math.PI * 2;
                    const speed = this.shrapnelSpeed + (Math.random() - 0.5) * 100;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    this.shrapnelPieces.push({
                        pos: new Vector2D(this.pos.x, this.pos.y),
                        vel: new Vector2D(vx, vy),
                        lifetime: 1.5,
                        maxLifetime: 1.5,
                        color: this.color
                    });
                }
            }

            expired() {
                return this.exploded && this.shrapnelPieces.length === 0;
            }

            draw(ctx, viewport) {
                if (!this.exploded) {
                    // Draw the bomb (no fading since they don't have lifetime limits)
                    const screenPos = viewport.worldToScreen(this.pos.x, this.pos.y);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw shrapnel
                    for (const shrapnel of this.shrapnelPieces) {
                        const screenPos = viewport.worldToScreen(shrapnel.pos.x, shrapnel.pos.y);
                        const alpha = shrapnel.lifetime / shrapnel.maxLifetime;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = shrapnel.color;
                        ctx.fillRect(screenPos.x - 1, screenPos.y - 1, 2, 2);
                    }
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Wall class - blocks bullets and bounces bombs
        class Wall {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.bricks = [];
                this.brickSize = 20;
                this.brickCount = 6;
                this.lifetime = 30; // Wall lasts 30 seconds
                this.maxLifetime = this.lifetime;

                // Create 6 bricks in a straight line behind the ship
                for (let i = 0; i < this.brickCount; i++) {
                    // Straight line behind ship direction
                    const backwardX = Math.sin(angle + Math.PI);
                    const backwardY = -Math.cos(angle + Math.PI);

                    this.bricks.push({
                        x: x + (backwardX * (i + 1) * this.brickSize),
                        y: y + (backwardY * (i + 1) * this.brickSize),
                        destroyed: false
                    });
                }
            }

            update(deltaTime) {
                this.lifetime -= deltaTime;
            }

            expired() {
                return this.lifetime <= 0 || this.bricks.every(brick => brick.destroyed);
            }

            checkBulletCollision(bullet) {
                for (let brick of this.bricks) {
                    if (!brick.destroyed) {
                        const dx = bullet.pos.x - brick.x;
                        const dy = bullet.pos.y - brick.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.brickSize / 2 + bullet.size / 2) {
                            if (bullet.canBounce && bullet.bounceCount < bullet.maxBounces && !bullet.hasHitWall) {
                                // Bounce bullet off wall
                                const angle = Math.atan2(dy, dx);
                                const speed = Math.sqrt(bullet.vel.x * bullet.vel.x + bullet.vel.y * bullet.vel.y);
                                bullet.vel.x = Math.cos(angle) * speed;
                                bullet.vel.y = Math.sin(angle) * speed;

                                // Move bullet away from wall to prevent stuck
                                bullet.pos.x = brick.x + Math.cos(angle) * (this.brickSize / 2 + bullet.size / 2 + 5);
                                bullet.pos.y = brick.y + Math.sin(angle) * (this.brickSize / 2 + bullet.size / 2 + 5);

                                bullet.bounceCount++;
                                bullet.hasHitWall = true;
                                bullet.vel.scale(0.8); // Reduce velocity on wall bounce

                                return false; // Bullet bounced, not destroyed
                            } else {
                                // Bullet destroyed by wall
                                brick.destroyed = true;
                                return true; // Bullet destroyed
                            }
                        }
                    }
                }
                return false;
            }

            checkBombCollision(bomb) {
                for (let brick of this.bricks) {
                    if (!brick.destroyed) {
                        const dx = bomb.pos.x - brick.x;
                        const dy = bomb.pos.y - brick.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.brickSize / 2 + bomb.size) {
                            if (bomb.wallBounceCount < bomb.maxWallBounces) {
                                // Bounce bomb off wall
                                const angle = Math.atan2(dy, dx);
                                const speed = Math.sqrt(bomb.vel.x * bomb.vel.x + bomb.vel.y * bomb.vel.y);
                                bomb.vel.x = Math.cos(angle) * speed;
                                bomb.vel.y = Math.sin(angle) * speed;

                                // Move bomb away from wall to prevent stuck
                                bomb.pos.x = brick.x + Math.cos(angle) * (this.brickSize / 2 + bomb.size + 5);
                                bomb.pos.y = brick.y + Math.sin(angle) * (this.brickSize / 2 + bomb.size + 5);

                                bomb.wallBounceCount++; // Increment wall bounce counter

                                return true; // Bomb bounced
                            } else {
                                // Bomb has already bounced once off walls - explode it
                                bomb.explode();
                                return true; // Bomb exploded
                            }
                        }
                    }
                }
                return false;
            }

            checkShipCollision(ship) {
                for (let brick of this.bricks) {
                    if (!brick.destroyed) {
                        const dx = ship.pos.x - brick.x;
                        const dy = ship.pos.y - brick.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.brickSize / 2 + ship.size / 2) {
                            // Block ship movement - push ship away from wall
                            const angle = Math.atan2(dy, dx);
                            const pushDistance = this.brickSize / 2 + ship.size / 2 + 2;

                            ship.pos.x = brick.x + Math.cos(angle) * pushDistance;
                            ship.pos.y = brick.y + Math.sin(angle) * pushDistance;

                            // Also dampen velocity in collision direction
                            const velAngle = Math.atan2(ship.vel.y, ship.vel.x);
                            const angleDiff = Math.abs(velAngle - (angle + Math.PI));

                            if (angleDiff < Math.PI / 2) {
                                // Moving toward wall, stop that velocity component
                                ship.vel.scale(0.3);
                            }

                            return true; // Ship blocked
                        }
                    }
                }
                return false;
            }

            draw(ctx, viewport) {
                for (let brick of this.bricks) {
                    if (!brick.destroyed) {
                        const screenPos = viewport.worldToScreen(brick.x, brick.y);
                        const alpha = this.lifetime / this.maxLifetime;

                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#666666';
                        ctx.fillRect(screenPos.x - this.brickSize/2, screenPos.y - this.brickSize/2,
                                   this.brickSize, this.brickSize);

                        // Border
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenPos.x - this.brickSize/2, screenPos.y - this.brickSize/2,
                                     this.brickSize, this.brickSize);
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        // Viewport class for camera/scrolling
        class Viewport {
            constructor(canvasWidth, canvasHeight) {
                this.width = canvasWidth;
                this.height = canvasHeight;
                this.x = 0; // World position of viewport center
                this.y = 0;

                // World size (much larger than viewport)
                this.worldWidth = 8000;
                this.worldHeight = 6000;
            }

            follow(entity) {
                // Center viewport on entity
                this.x = entity.pos.x;
                this.y = entity.pos.y;

                // Keep viewport within world bounds
                this.x = Math.max(this.width / 2, Math.min(this.worldWidth - this.width / 2, this.x));
                this.y = Math.max(this.height / 2, Math.min(this.worldHeight - this.height / 2, this.y));
            }

            worldToScreen(worldX, worldY) {
                return {
                    x: worldX - this.x + this.width / 2,
                    y: worldY - this.y + this.height / 2
                };
            }

            screenToWorld(screenX, screenY) {
                return {
                    x: screenX + this.x - this.width / 2,
                    y: screenY + this.y - this.height / 2
                };
            }

            isVisible(entity) {
                const margin = 100; // Extra margin for smooth appearance
                return entity.pos.x > this.x - this.width / 2 - margin &&
                       entity.pos.x < this.x + this.width / 2 + margin &&
                       entity.pos.y > this.y - this.height / 2 - margin &&
                       entity.pos.y < this.y + this.height / 2 + margin;
            }
        }

        // Main game class
        class SubspaceGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                // Turn off smoothing for crisp pixel art
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.mozImageSmoothingEnabled = false;
                this.ctx.webkitImageSmoothingEnabled = false;
                this.ctx.msImageSmoothingEnabled = false;

                // Load simple ship sprite (like Valor does)
                this.shipImage = new Image();
                this.shipLoaded = false;
                this.processedShipCanvas = null;
                this.shipImage.onload = () => {
                    // Create an offscreen canvas the same size as shipImage
                    const off = document.createElement('canvas');
                    off.width = this.shipImage.width;
                    off.height = this.shipImage.height;
                    const offCtx = off.getContext('2d');

                    // Draw the sprite sheet into it
                    offCtx.drawImage(this.shipImage, 0, 0);

                    // Access pixel data and make black pixels transparent
                    const imgData = offCtx.getImageData(0, 0, off.width, off.height);
                    const data = imgData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        // treat very dark pixels as transparent
                        if (r < 16 && g < 16 && b < 16) {
                            data[i + 3] = 0;
                        }
                    }
                    offCtx.putImageData(imgData, 0, 0);

                    // Use the processed canvas as the sprite source
                    this.processedShipCanvas = off;
                    this.shipLoaded = true;
                    console.log('Processed ship sprite loaded successfully');
                };
                this.shipImage.src = 'ships.png'; // Use the full 8-ship sprite sheet

                // Ship config for 8 ship types, 36 rotation frames per ship in a grid
                this.shipFrameWidth = 40;   // Each frame is 40px wide
                this.shipFrameHeight = 36;  // Each frame is 36px tall
                this.rotationFrames = 36;   // 9 columns × 4 rows = 36 rotation frames per ship

                // Ship types for the HUD
                this.shipTypes = {
                    1: { name: 'Warbird' },
                    2: { name: 'Javelin' },
                    3: { name: 'Spider' },
                    4: { name: 'Leviathan' },
                    5: { name: 'Terrier' },
                    6: { name: 'Weasel' },
                    7: { name: 'Lancaster' },
                    8: { name: 'Shark' }
                };

                // Game state
                this.running = true;
                this.lastTime = 0;

                // Multiplayer state
                this.isMultiplayer = false;
                this.playerId = null;
                this.otherPlayers = new Map();
                this.ws = null;

                // Viewport for camera system
                this.viewport = new Viewport(this.canvas.width, this.canvas.height);

                // Create player ship in world coordinates
                this.playerShip = new Ship(this.viewport.worldWidth / 2, this.viewport.worldHeight / 2, true);

                // Other ships for testing
                this.ships = [this.playerShip];

                // Power-ups system
                this.powerUps = [];
                this.powerUpSpawnTimer = 0;
                this.powerUpSpawnInterval = 4; // Spawn every 4 seconds (100% more frequent)
                this.powerUpsCollected = 0; // Player's bounty/score

                // Weapons system
                this.bombs = [];

                // Walls system
                this.walls = [];

                // Bounty timer system
                this.bountyTimer = 0;
                this.bountyInterval = 60; // 1 minute in seconds
                this.bountyIncrease = 50;

                // Input state
                this.keys = {};
                this.input = {
                    left: false,
                    right: false,
                    thrust: false,
                    reverse: false,
                    brake: false,
                    fire: false,
                    bomb: false,
                    deployWall: false,
                    burst: false
                };

                this.setupEventListeners();

                // Spawn initial power-ups
                this.spawnInitialPowerUps();

                // Make game available globally for bomb firing
                window.game = this;

                // Setup config panel
                this.setupConfigPanel();

                this.gameLoop();
            }

            connectToMultiplayer() {
                const statusEl = document.getElementById('multiplayerStatus');
                const btnEl = document.getElementById('multiplayerBtn');

                statusEl.textContent = 'Connecting...';
                btnEl.disabled = true;

                this.ws = new WebSocket('wss://172.239.66.45:8443');
                this.isMultiplayer = true;

                this.ws.onopen = () => {
                    console.log('Connected to multiplayer server');
                    statusEl.textContent = 'Connected! Waiting for players...';
                    btnEl.textContent = 'CONNECTED';
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleMultiplayerMessage(data);

                    if (data.type === 'init') {
                        statusEl.textContent = `Connected as ${data.playerId}`;
                    }
                };

                this.ws.onclose = () => {
                    console.log('Disconnected from multiplayer server');
                    this.isMultiplayer = false;
                    this.otherPlayers.clear();
                    statusEl.textContent = 'Disconnected';
                    btnEl.textContent = 'JOIN MULTIPLAYER';
                    btnEl.disabled = false;
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Connection failed';
                    btnEl.disabled = false;
                };
            }

            handleMultiplayerMessage(data) {
                switch (data.type) {
                    case 'init':
                        this.playerId = data.playerId;
                        data.players.forEach(player => {
                            if (player.id !== this.playerId) {
                                this.otherPlayers.set(player.id, new Ship(player.x, player.y, false));
                            }
                        });
                        break;

                    case 'playerJoined':
                        if (data.player.id !== this.playerId) {
                            this.otherPlayers.set(data.player.id, new Ship(data.player.x, data.player.y, false));
                        }
                        break;

                    case 'playerLeft':
                        this.otherPlayers.delete(data.playerId);
                        break;

                    case 'playerMove':
                        const player = this.otherPlayers.get(data.playerId);
                        if (player) {
                            player.pos.x = data.x;
                            player.pos.y = data.y;
                            player.angle = data.rotation;
                        }
                        break;

                    case 'bullet':
                        if (data.playerId !== this.playerId) {
                            const bullet = new Bullet(data.x, data.y, data.vx, data.vy);
                            this.playerShip.bullets.push(bullet);
                        }
                        break;

                    case 'bomb':
                        if (data.playerId !== this.playerId) {
                            const bomb = new Bomb(data.x, data.y, data.vx, data.vy, data.color);
                            this.bombs.push(bomb);
                        }
                        break;

                    case 'wall':
                        if (data.playerId !== this.playerId) {
                            data.bricks.forEach(brick => {
                                this.walls.push(new Wall(brick.x, brick.y));
                            });
                        }
                        break;

                    case 'burst':
                        if (data.playerId !== this.playerId) {
                            this.applyBurst(data.x, data.y);
                        }
                        break;
                    case 'playerDamage':
                        if (data.targetId === this.playerId) {
                            this.damagePlayer(data.bulletLevel || data.bulletType || 0);
                        }
                        break;
                    case 'bombDamage':
                        if (data.targetId === this.playerId) {
                            this.playerShip.shield -= data.damage;
                            if (this.playerShip.shield <= 0) {
                                this.playerShip.shield = 0;
                                // Player died - respawn
                                this.playerShip.pos.x = this.viewport.worldWidth / 2;
                                this.playerShip.pos.y = this.viewport.worldHeight / 2;
                                this.playerShip.shield = this.playerShip.maxShield;
                            }
                        }
                        break;
                    case 'bombExplosion':
                        // Create visual explosion effect and shrapnel
                        this.createRemoteBombExplosion(data.x, data.y, data.bombType);
                        break;
                }
            }

            sendMultiplayerMessage(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }

            checkBulletPlayerCollision(bullet, player) {
                const dx = bullet.pos.x - player.pos.x;
                const dy = bullet.pos.y - player.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (bullet.size + player.size) / 2;
            }

            damagePlayer(bulletLevel) {
                // Use the same damage values as the bullet configs (6 levels)
                const damageLevels = [30, 40, 60, 75, 90, 120];
                const damage = damageLevels[Math.min(bulletLevel, 5)] || 30;

                this.playerShip.shield -= damage;
                console.log(`Hit by level ${bulletLevel} bullet for ${damage} damage`);
                if (this.playerShip.shield <= 0) {
                    this.playerShip.shield = 0;
                    // Player died - respawn
                    this.playerShip.pos.x = this.viewport.worldWidth / 2;
                    this.playerShip.pos.y = this.viewport.worldHeight / 2;
                    this.playerShip.shield = this.playerShip.maxShield;
                }
            }

            sendPlayerDamage(playerId, bulletType) {
                this.sendMultiplayerMessage({
                    type: 'playerDamage',
                    targetId: playerId,
                    bulletType: bulletType
                });
            }

            checkBombPlayerProximity(bomb, player, radius) {
                const dx = bomb.pos.x - player.pos.x;
                const dy = bomb.pos.y - player.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < radius;
            }

            explodeBomb(bomb, bombIndex) {
                const explosionRadius = 120;
                const shrapnelCount = 8;

                // Remove the bomb
                this.bombs.splice(bombIndex, 1);

                // Create shrapnel bullets in all directions
                for (let i = 0; i < shrapnelCount; i++) {
                    const angle = (i / shrapnelCount) * Math.PI * 2;
                    const shrapnel = new Bullet(
                        bomb.pos.x,
                        bomb.pos.y,
                        Math.cos(angle) * 400,
                        Math.sin(angle) * 400,
                        bomb.type // Same type as the bomb
                    );
                    this.playerShip.bullets.push(shrapnel);
                }

                // Damage all players within explosion radius
                this.damagePlayersInRadius(bomb.pos.x, bomb.pos.y, explosionRadius, bomb.type);

                // Send explosion to multiplayer
                this.sendMultiplayerMessage({
                    type: 'bombExplosion',
                    x: bomb.pos.x,
                    y: bomb.pos.y,
                    bombType: bomb.type
                });
            }

            damagePlayersInRadius(x, y, radius, bombType) {
                // Damage local player
                const localDx = this.playerShip.pos.x - x;
                const localDy = this.playerShip.pos.y - y;
                const localDistance = Math.sqrt(localDx * localDx + localDy * localDy);

                if (localDistance < radius) {
                    const damageMult = 1 - (localDistance / radius); // Closer = more damage
                    let baseDamage = bombType === 'yellow' ? 80 : 50;
                    const finalDamage = Math.floor(baseDamage * damageMult);

                    this.playerShip.shield -= finalDamage;
                    if (this.playerShip.shield <= 0) {
                        this.playerShip.shield = 0;
                        // Player died - respawn
                        this.playerShip.pos.x = this.viewport.worldWidth / 2;
                        this.playerShip.pos.y = this.viewport.worldHeight / 2;
                        this.playerShip.shield = this.playerShip.maxShield;
                    }
                }

                // Damage other multiplayer players
                for (const [playerId, otherPlayer] of this.otherPlayers) {
                    const dx = otherPlayer.pos.x - x;
                    const dy = otherPlayer.pos.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius) {
                        const damageMult = 1 - (distance / radius);
                        let baseDamage = bombType === 'yellow' ? 80 : 50;
                        const finalDamage = Math.floor(baseDamage * damageMult);

                        this.sendMultiplayerMessage({
                            type: 'bombDamage',
                            targetId: playerId,
                            damage: finalDamage
                        });
                    }
                }
            }

            createRemoteBombExplosion(x, y, bombType) {
                const shrapnelCount = 8;

                // Create shrapnel bullets in all directions
                for (let i = 0; i < shrapnelCount; i++) {
                    const angle = (i / shrapnelCount) * Math.PI * 2;
                    const shrapnel = new Bullet(
                        x,
                        y,
                        Math.cos(angle) * 400,
                        Math.sin(angle) * 400,
                        bombType
                    );
                    this.playerShip.bullets.push(shrapnel);
                }
            }

            drawShipSprite(shipType, x, y, angle) {
                // If the sprite hasn't loaded yet, bail out
                if (!this.shipLoaded || !this.processedShipCanvas) return false;

                // Use the first frame (upright) and rotate with canvas transform
                const baseCol = 0;
                const baseRow = 0;

                // Offset to the correct ship type (each type occupies 4 rows of frames)
                const baseY = (shipType - 1) * 4 * this.shipFrameHeight;

                // Sample the central 32×32 pixels of that frame
                const srcX = baseCol * this.shipFrameWidth + 4;
                const srcY = baseY + baseRow * this.shipFrameHeight + 2;
                const srcW = 32;
                const srcH = 32;

                const dest = this.playerShip.spriteDrawSize;

                this.ctx.save();

                // Move to ship center, then rotate around the ship's centre
                this.ctx.translate(x, y);
                this.ctx.rotate(angle);

                // Draw the upright ship rotated
                this.ctx.drawImage(
                    this.processedShipCanvas,
                    srcX, srcY, srcW, srcH,
                    -dest / 2, -dest / 2,
                    dest, dest
                );

                this.ctx.restore();
                return true; // prevent fallback triangle
            }

            changeShip(direction) {
                // Change the player's ship type (1-8)
                this.playerShip.shipType += direction;
                if (this.playerShip.shipType < 1) this.playerShip.shipType = 8;
                if (this.playerShip.shipType > 8) this.playerShip.shipType = 1;

                // Update the HUD display
                const shipName = this.shipTypes[this.playerShip.shipType]?.name || 'Unknown';
                document.getElementById('shipType').textContent = shipName;

                // Send ship change to multiplayer if connected
                if (this.isMultiplayer && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'shipChange',
                        shipType: this.playerShip.shipType
                    }));
                }
            }

            showPowerUpMessage(powerUpConfig) {
                // Create the message element
                const messageEl = document.createElement('div');
                messageEl.className = 'power-up-message';
                messageEl.style.color = powerUpConfig.color;
                messageEl.style.borderColor = powerUpConfig.color;
                messageEl.style.textShadow = `2px 2px 4px #000, 0 0 15px ${powerUpConfig.color}`;
                messageEl.innerHTML = `
                    <div style="font-size: 28px; margin-bottom: 5px;">${powerUpConfig.name}</div>
                    <div style="font-size: 18px;">${powerUpConfig.message}</div>
                `;

                // Add to container
                const container = document.getElementById('messageContainer');
                container.appendChild(messageEl);

                // Play power-up sound (Web Audio API)
                this.playPowerUpSound(powerUpConfig.effect);

                // Remove message after animation
                setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.parentNode.removeChild(messageEl);
                    }
                }, 3000);
            }

            playPowerUpSound(type) {
                // Create Web Audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Different sound frequencies for different power-ups
                const frequencies = {
                    energy: [440, 880], // A4 to A5
                    speed: [523, 1047], // C5 to C6
                    weapons: [659, 1319], // E5 to E6
                    shield: [392, 784], // G4 to G5
                    recharge: [494, 988], // B4 to B5
                    thrust: [587, 1175], // D5 to D6
                    rotation: [698, 1397] // F5 to F6
                };

                const freqs = frequencies[type] || frequencies.energy;

                // Create oscillator for power-up sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Configure sound
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freqs[0], audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freqs[1], audioContext.currentTime + 0.3);

                // Volume envelope
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

                // Play sound
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }

            spawnInitialPowerUps() {
                const powerUpTypes = ['energy', 'speed', 'weapons', 'shield', 'recharge', 'thrust', 'rotation', 'wall'];

                // Spawn 6 initial power-ups (100% increase from 3)
                for (let i = 0; i < 6; i++) {
                    const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    const x = Math.random() * (this.viewport.worldWidth - 200) + 100;
                    const y = Math.random() * (this.viewport.worldHeight - 200) + 100;

                    this.powerUps.push(new PowerUp(x, y, type));
                }
            }

            spawnPowerUp() {
                const powerUpTypes = ['energy', 'speed', 'weapons', 'shield', 'recharge', 'thrust', 'rotation', 'wall'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                console.log(`Spawning power-up: ${type}`); // Debug log

                // Spawn away from player but within reasonable distance
                const minDistance = 200;
                const maxDistance = 800;
                const angle = Math.random() * Math.PI * 2;
                const distance = minDistance + Math.random() * (maxDistance - minDistance);

                const x = Math.max(50, Math.min(this.viewport.worldWidth - 50,
                    this.playerShip.pos.x + Math.cos(angle) * distance));
                const y = Math.max(50, Math.min(this.viewport.worldHeight - 50,
                    this.playerShip.pos.y + Math.sin(angle) * distance));

                this.powerUps.push(new PowerUp(x, y, type));
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.updateInput();
                    e.preventDefault();
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    this.updateInput();
                    e.preventDefault();
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            updateInput() {
                this.input.left = this.keys['KeyA'] || this.keys['ArrowLeft'];
                this.input.right = this.keys['KeyD'] || this.keys['ArrowRight'];
                this.input.thrust = this.keys['KeyW'] || this.keys['ArrowUp'];
                this.input.reverse = this.keys['KeyS'] || this.keys['ArrowDown'];
                this.input.brake = this.keys['Space'];
                this.input.fire = this.keys['ControlLeft'] || this.keys['ControlRight'];
                this.input.bomb = this.keys['Tab'];
                this.input.deployWall = this.keys['F2'];
                this.input.burst = this.keys['F3'];

                // Handle F12 for config panel
                if (this.keys['F12']) {
                    this.toggleConfigPanel();
                    this.keys['F12'] = false; // Prevent repeated toggles
                }
            }

            updateHUD() {
                const ship = this.playerShip;

                // Basic stats
                document.getElementById('energy').textContent = Math.floor(ship.energy);
                document.getElementById('maxEnergy').textContent = ship.maxEnergy;
                document.getElementById('shield').textContent = Math.floor(ship.shield || 0);
                document.getElementById('maxShield').textContent = ship.maxShield;
                document.getElementById('powerUps').textContent = this.powerUpsCollected;
                document.getElementById('wallCount').textContent = ship.wallCount;
                document.getElementById('deaths').textContent = ship.deaths;

                // Upgrade levels and their effects
                const shipName = this.shipTypes[ship.shipType]?.name || 'Unknown';
                document.getElementById('shipType').textContent = shipName;
                document.getElementById('energyLevel').textContent = ship.energyLevel;
                document.getElementById('speedLevel').textContent = ship.maxSpeedLevel;
                document.getElementById('maxSpeed').textContent = Math.floor(ship.maxSpeed);
                document.getElementById('bulletType').textContent = ship.bulletType.charAt(0).toUpperCase() + ship.bulletType.slice(1);

                // Show bullet bouncing status for 6-level system
                let bounceText = '';
                if (ship.weaponLevel === 1 || ship.weaponLevel === 5) {
                    bounceText = '(Bouncing)';
                } else {
                    bounceText = '(No Bounce)';
                }
                document.getElementById('bulletBounce').textContent = bounceText;

                // Show bullet damage for 6-level system
                const damageLevels = [30, 40, 60, 75, 90, 120];
                const currentDamage = damageLevels[Math.min(ship.weaponLevel, 5)] || 30;
                document.getElementById('bulletDamage').textContent = currentDamage;
                document.getElementById('bombType').textContent = ship.bulletType.charAt(0).toUpperCase() + ship.bulletType.slice(1);
                document.getElementById('rechargeLevel').textContent = ship.rechargeLevel;
                document.getElementById('rechargeRate').textContent = Math.floor((ship.energyRecharge - 50) / 50 * 100); // Show actual percentage increase
                document.getElementById('thrustLevel').textContent = ship.thrustLevel;
                document.getElementById('thrustBonus').textContent = Math.floor(ship.thrustLevel * 2);
                document.getElementById('rotationLevel').textContent = ship.rotationLevel;
                const rotationBonus = Math.floor(ship.rotationLevel * 33);
                const rotationText = ship.rotationLevel >= 3 ? `${rotationBonus}% (MAX)` : `${rotationBonus}%`;
                document.getElementById('rotationBonus').textContent = rotationText;
                document.getElementById('shieldLevel').textContent = ship.shieldLevel;

                // Energy bar
                const energyFill = document.getElementById('energyFill');
                energyFill.style.width = (ship.energy / ship.maxEnergy * 100) + '%';
            }

            draw() {
                // Debug: Log drawing info (commented out to reduce spam)
                // console.log(`Drawing: canvas ${this.canvas.width}x${this.canvas.height}, player at (${this.playerShip.pos.x}, ${this.playerShip.pos.y})`);

                // Update viewport to follow player
                this.viewport.follow(this.playerShip);

                // Clear canvas with proper space background gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#001122');
                gradient.addColorStop(0.5, '#002244');
                gradient.addColorStop(1, '#001122');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw scrolling stars
                this.drawStars();

                // Draw all ships that are visible
                for (const ship of this.ships) {
                    if (this.viewport.isVisible(ship)) {
                        ship.draw(this.ctx, this.viewport);
                    }
                }

                // Draw other multiplayer players
                if (this.isMultiplayer) {
                    for (const [playerId, player] of this.otherPlayers) {
                        if (this.viewport.isVisible(player)) {
                            player.draw(this.ctx, this.viewport);
                        }
                    }
                }

                // Draw power-ups
                for (const powerUp of this.powerUps) {
                    if (this.viewport.isVisible(powerUp)) {
                        powerUp.draw(this.ctx, this.viewport);
                    }
                }

                // Draw bombs
                for (const bomb of this.bombs) {
                    bomb.draw(this.ctx, this.viewport);
                }

                // Draw walls
                for (const wall of this.walls) {
                    wall.draw(this.ctx, this.viewport);
                }

                // Draw burst effects
                if (this.burstEffects) {
                    for (const burst of this.burstEffects) {
                        const screenPos = this.viewport.worldToScreen(burst.x, burst.y);
                        const alpha = burst.lifetime / burst.maxLifetime;

                        this.ctx.globalAlpha = alpha * 0.5;
                        this.ctx.strokeStyle = '#00FFFF';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x, screenPos.y, burst.radius * this.viewport.zoom, 0, Math.PI * 2);
                        this.ctx.stroke();

                        this.ctx.globalAlpha = alpha * 0.2;
                        this.ctx.fillStyle = '#00FFFF';
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;
                    }
                }

                // Only draw world boundaries if we're near them
                this.drawWorldBounds();
            }

            drawStars() {
                this.ctx.fillStyle = '#ffffff';

                // Calculate visible star region based on viewport
                const margin = 50;
                const startX = Math.max(0, Math.floor((this.viewport.x - this.viewport.width / 2 - margin) / 127));
                const endX = Math.min(Math.floor(this.viewport.worldWidth / 127), Math.ceil((this.viewport.x + this.viewport.width / 2 + margin) / 127));
                const startY = Math.max(0, Math.floor((this.viewport.y - this.viewport.height / 2 - margin) / 191));
                const endY = Math.min(Math.floor(this.viewport.worldHeight / 191), Math.ceil((this.viewport.y + this.viewport.height / 2 + margin) / 191));

                // Draw stars in visible region only
                for (let x = startX; x <= endX; x++) {
                    for (let y = startY; y <= endY; y++) {
                        const worldX = x * 127;
                        const worldY = y * 191;

                        if (worldX < this.viewport.worldWidth && worldY < this.viewport.worldHeight) {
                            const screenPos = this.viewport.worldToScreen(worldX, worldY);

                            // Make sure star is actually on screen
                            if (screenPos.x >= -5 && screenPos.x <= this.canvas.width + 5 &&
                                screenPos.y >= -5 && screenPos.y <= this.canvas.height + 5) {
                                const size = ((x + y) % 3) + 1;
                                this.ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), size, size);
                            }
                        }
                    }
                }
            }

            drawWorldBounds() {
                // Only draw boundaries if we're near the world edge
                const margin = 200;
                const ship = this.playerShip;

                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([20, 10]);

                // Left edge
                if (ship.pos.x < margin) {
                    const screenPos = this.viewport.worldToScreen(0, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                }

                // Right edge
                if (ship.pos.x > this.viewport.worldWidth - margin) {
                    const screenPos = this.viewport.worldToScreen(this.viewport.worldWidth, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                }

                // Top edge
                if (ship.pos.y < margin) {
                    const screenPos = this.viewport.worldToScreen(0, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenPos.y);
                    this.ctx.lineTo(this.canvas.width, screenPos.y);
                    this.ctx.stroke();
                }

                // Bottom edge
                if (ship.pos.y > this.viewport.worldHeight - margin) {
                    const screenPos = this.viewport.worldToScreen(0, this.viewport.worldHeight);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenPos.y);
                    this.ctx.lineTo(this.canvas.width, screenPos.y);
                    this.ctx.stroke();
                }

                this.ctx.setLineDash([]);
            }

            createBurst(x, y) {
                const burstRadius = 150;
                const burstForce = 800;

                // Push bombs away
                for (const bomb of this.bombs) {
                    const dx = bomb.pos.x - x;
                    const dy = bomb.pos.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < burstRadius && distance > 0) {
                        const force = burstForce * (1 - distance / burstRadius);
                        const pushX = (dx / distance) * force;
                        const pushY = (dy / distance) * force;

                        bomb.vel.x += pushX;
                        bomb.vel.y += pushY;
                    }
                }

                // Push bullets away
                for (const ship of this.ships) {
                    for (const bullet of ship.bullets) {
                        const dx = bullet.pos.x - x;
                        const dy = bullet.pos.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < burstRadius && distance > 0) {
                            const force = burstForce * (1 - distance / burstRadius);
                            const pushX = (dx / distance) * force;
                            const pushY = (dy / distance) * force;

                            bullet.vel.x += pushX;
                            bullet.vel.y += pushY;
                        }
                    }
                }

                // Create visual burst effect
                this.burstEffects = this.burstEffects || [];
                this.burstEffects.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: burstRadius,
                    lifetime: 0.8,
                    maxLifetime: 0.8
                });
            }

            setupConfigPanel() {
                // Setup sliders for upgrade levels
                const sliders = {
                    energyLevel: { slider: 'energyLevelSlider', value: 'energyLevelValue', property: 'energyLevel' },
                    speedLevel: { slider: 'speedLevelSlider', value: 'speedLevelValue', property: 'maxSpeedLevel' },
                    weaponLevel: { slider: 'weaponLevelSlider', value: 'weaponLevelValue', property: 'weaponLevel' },
                    rechargeLevel: { slider: 'rechargeLevelSlider', value: 'rechargeLevelValue', property: 'rechargeLevel' },
                    thrustLevel: { slider: 'thrustLevelSlider', value: 'thrustLevelValue', property: 'thrustLevel' },
                    rotationLevel: { slider: 'rotationLevelSlider', value: 'rotationLevelValue', property: 'rotationLevel' },
                    shieldLevel: { slider: 'shieldLevelSlider', value: 'shieldLevelValue', property: 'shieldLevel' },
                    wallCount: { slider: 'wallCountSlider', value: 'wallCountValue', property: 'wallCount' }
                };

                Object.entries(sliders).forEach(([key, config]) => {
                    const slider = document.getElementById(config.slider);
                    const valueDisplay = document.getElementById(config.value);

                    if (slider && valueDisplay) {
                        // Initialize slider with current ship values
                        slider.value = this.playerShip[config.property] || 0;
                        valueDisplay.textContent = slider.value;

                        slider.addEventListener('input', (e) => {
                            const value = parseInt(e.target.value);
                            valueDisplay.textContent = value;

                            // Update the ship upgrade level directly
                            this.playerShip[config.property] = value;

                            // Force recalculation of ship stats
                            this.playerShip.updateStatsFromLevels();

                            // Update HUD to reflect changes
                            this.updateHUD();
                        });
                    }
                });

                // Special handler for fire rate (modifies ship config, not ship property)
                const fireRateSlider = document.getElementById('fireRateSlider');
                const fireRateValue = document.getElementById('fireRateValue');
                if (fireRateSlider && fireRateValue) {
                    fireRateSlider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        fireRateValue.textContent = value.toFixed(1);

                        // Update ship config gunTimeoutMultiplier
                        window.shipConfig.updateConfig(1, 'gunTimeoutMultiplier', value);

                        // Force recalculation of gun timeout
                        const config = window.shipConfig.getConfig(this.playerShip.shipType);
                        this.playerShip.gunTimeoutDefault = 0.5 * (config.gunTimeoutMultiplier || 1.0);
                    });
                }
            }

            toggleConfigPanel() {
                const panel = document.getElementById('configPanel');
                if (panel) {
                    const isHidden = panel.style.display === 'none';
                    panel.style.display = isHidden ? 'block' : 'none';

                    // Refresh slider values when opening the panel
                    if (isHidden) {
                        this.refreshConfigPanel();
                    }
                }
            }

            refreshConfigPanel() {
                // Update all sliders to reflect current ship upgrade levels
                const updates = {
                    'energyLevelSlider': this.playerShip.energyLevel,
                    'speedLevelSlider': this.playerShip.maxSpeedLevel,
                    'weaponLevelSlider': this.playerShip.weaponLevel,
                    'rechargeLevelSlider': this.playerShip.rechargeLevel,
                    'thrustLevelSlider': this.playerShip.thrustLevel,
                    'rotationLevelSlider': this.playerShip.rotationLevel,
                    'shieldLevelSlider': this.playerShip.shieldLevel,
                    'wallCountSlider': this.playerShip.wallCount
                };

                Object.entries(updates).forEach(([sliderId, value]) => {
                    const slider = document.getElementById(sliderId);
                    const valueDisplay = document.getElementById(sliderId.replace('Slider', 'Value'));
                    if (slider && valueDisplay) {
                        slider.value = value || 0;
                        valueDisplay.textContent = value || 0;
                    }
                });

                // Update fire rate slider
                const fireRateSlider = document.getElementById('fireRateSlider');
                const fireRateValue = document.getElementById('fireRateValue');
                const config = window.shipConfig.getConfig(this.playerShip.shipType);
                if (fireRateSlider && fireRateValue && config) {
                    const currentRate = config.gunTimeoutMultiplier || 1.0;
                    fireRateSlider.value = currentRate;
                    fireRateValue.textContent = currentRate.toFixed(1);
                }
            }

            gameLoop(currentTime = 0) {
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;

                // Debug: Log first few frames
                if (currentTime < 5000) {
                    console.log(`Frame ${Math.floor(currentTime)}: playerShip at (${this.playerShip.pos.x}, ${this.playerShip.pos.y})`);
                }

                if (this.running && deltaTime < 0.1) { // Cap deltaTime to prevent large jumps
                    // Update player ship
                    this.playerShip.processInput(this.input, deltaTime);

                    // Send player movement to server if multiplayer
                    if (this.isMultiplayer && (this.input.left || this.input.right || this.input.thrust || this.input.reverse)) {
                        this.sendMultiplayerMessage({
                            type: 'move',
                            x: this.playerShip.pos.x,
                            y: this.playerShip.pos.y,
                            rotation: this.playerShip.angle,
                            thrust: this.input.thrust
                        });
                    }

                    // Update all ships
                    for (const ship of this.ships) {
                        ship.update(deltaTime);
                    }

                    // Update other players
                    if (this.isMultiplayer) {
                        for (const [playerId, player] of this.otherPlayers) {
                            player.update(deltaTime);
                        }
                    }

                    // Update power-ups
                    for (const powerUp of this.powerUps) {
                        powerUp.update(deltaTime);

                        // Check collision with player
                        if (powerUp.checkCollision(this.playerShip)) {
                            powerUp.applyEffect(this.playerShip);
                            this.powerUpsCollected++; // Increment bounty counter
                            this.showPowerUpMessage(powerUp.config); // Show announcement
                        }
                    }

                    // Remove collected power-ups
                    this.powerUps = this.powerUps.filter(p => !p.collected);

                    // Update bombs
                    for (const bomb of this.bombs) {
                        bomb.update(deltaTime);
                    }

                    // Remove expired bombs
                    this.bombs = this.bombs.filter(bomb => !bomb.expired());

                    // Update walls
                    for (const wall of this.walls) {
                        wall.update(deltaTime);
                    }

                    // Remove expired walls
                    this.walls = this.walls.filter(wall => !wall.expired());

                    // Check bullet-wall collisions
                    for (const ship of this.ships) {
                        for (let i = ship.bullets.length - 1; i >= 0; i--) {
                            const bullet = ship.bullets[i];
                            for (const wall of this.walls) {
                                if (wall.checkBulletCollision(bullet)) {
                                    ship.bullets.splice(i, 1);
                                    break; // Bullet destroyed, check next bullet
                                }
                            }
                        }
                    }

                    // Check bullet-player collisions
                    for (const ship of this.ships) {
                        for (let i = ship.bullets.length - 1; i >= 0; i--) {
                            const bullet = ship.bullets[i];

                            // Check collision with local player
                            if (this.checkBulletPlayerCollision(bullet, this.playerShip)) {
                                this.damagePlayer(bullet.weaponLevel || bullet.upgradeLevel || 0);
                                ship.bullets.splice(i, 1);
                                continue;
                            }

                            // Check collision with other multiplayer players
                            for (const [playerId, otherPlayer] of this.otherPlayers) {
                                if (this.checkBulletPlayerCollision(bullet, otherPlayer)) {
                                    // Send damage to other player via server
                                    this.sendPlayerDamage(playerId, bullet.type);
                                    ship.bullets.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }

                    // Check bomb-wall collisions (bombs bounce)
                    for (const bomb of this.bombs) {
                        for (const wall of this.walls) {
                            wall.checkBombCollision(bomb); // Bomb bounces, wall might be damaged
                        }
                    }

                    // Check bomb proximity to players
                    for (let i = this.bombs.length - 1; i >= 0; i--) {
                        const bomb = this.bombs[i];
                        const proximityRadius = 60; // Bombs explode within 60 pixels

                        // Check proximity to local player
                        if (this.checkBombPlayerProximity(bomb, this.playerShip, proximityRadius)) {
                            this.explodeBomb(bomb, i);
                            continue;
                        }

                        // Check proximity to other multiplayer players
                        for (const [playerId, otherPlayer] of this.otherPlayers) {
                            if (this.checkBombPlayerProximity(bomb, otherPlayer, proximityRadius)) {
                                this.explodeBomb(bomb, i);
                                break;
                            }
                        }
                    }

                    // Check ship-wall collisions (ships are blocked)
                    for (const ship of this.ships) {
                        for (const wall of this.walls) {
                            wall.checkShipCollision(ship); // Ship blocked by wall
                        }
                    }

                    // Update burst effects
                    if (this.burstEffects) {
                        for (const burst of this.burstEffects) {
                            burst.lifetime -= deltaTime;
                            burst.radius = burst.maxRadius * (1 - burst.lifetime / burst.maxLifetime);
                        }
                        this.burstEffects = this.burstEffects.filter(burst => burst.lifetime > 0);
                    }

                    // Spawn new power-ups
                    this.powerUpSpawnTimer += deltaTime;
                    if (this.powerUpSpawnTimer >= this.powerUpSpawnInterval) {
                        this.spawnPowerUp();
                        this.powerUpSpawnTimer = 0;
                    }

                    // Update bounty timer
                    this.bountyTimer += deltaTime;
                    if (this.bountyTimer >= this.bountyInterval) {
                        this.powerUpsCollected += this.bountyIncrease;
                        this.bountyTimer = 0;

                        // Show bounty increase message
                        const messageEl = document.createElement('div');
                        messageEl.className = 'power-up-message';
                        messageEl.style.color = '#FFD700';
                        messageEl.style.borderColor = '#FFD700';
                        messageEl.style.textShadow = '2px 2px 4px #000, 0 0 15px #FFD700';
                        messageEl.innerHTML = `
                            <div style="font-size: 28px; margin-bottom: 5px;">BOUNTY BONUS!</div>
                            <div style="font-size: 18px;">+${this.bountyIncrease} Bounty</div>
                        `;

                        const container = document.getElementById('messageContainer');
                        container.appendChild(messageEl);

                        setTimeout(() => {
                            if (messageEl.parentNode) {
                                messageEl.parentNode.removeChild(messageEl);
                            }
                        }, 3000);
                    }

                    this.updateHUD();
                    this.draw();
                }

                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // Start the game
        window.addEventListener('load', () => {
            window.game = new SubspaceGame();
        });
    </script>
</body>
</html>